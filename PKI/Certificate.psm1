<#

CERTIFICATE GENERATION MODULE

Matthew Schacherbauer
2019-07-13

https://github.com/matthewschacherbauer
https://www.matthewschacherbauer.com

===============

EXTERNAL RESOURCES REQUIRED

OpenSSL is required for this module to run.
By default, the OpenSSL directory is expected to be defined in the environment
variable $ENV:OpenSsl, or the path can be overridden with -OpenSslPath.

Java is required to convert a certificate into the Java Keystore format.
By default, the Java install is expected to be defined in the environment
variable $ENV:Java_Home, or the path can be overridden with -JavaPath.

===============

ENTERPRISE CA USAGE SUMMARY

-> New-CertificatePackage <-
Creates a CSR using OpenSSL.
Submits the CSR to a Microsoft Enterprise CA for signing.
Converts the resulting signed certificate to several popular formats.

EXTERNAL CA USAGE SUMMARY

-> New-CertificateSigningRequest <-
Creates a CSR using OpenSSL for manual submission to a public Certificate Authority.

-> Complete-CertificateSigningRequest <-
Combines a certificate signed by a public Certificate Authorit with the private key
generated by New-CertificateSigningRequest.
Converts the resulting signed certificate to several popular formats.

CERTIFICATE FORMAT CONVERSION SUMMARY

Additional commandlets are provided to convert pre-existing certificates to various
formats. These commandlets are used by the above general functions.

===============
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
===============

#>

#Requires -Version 3.0


Class PrivateKey {
	[bool]					$Encrypted
	[securestring]			$Passphrase
	[system.io.fileinfo]	$Path
}


Function isEncryptedPrivateKey {
	<#
	.SYNOPSIS
	Checks if the Private Key is encrypted.
	.PARAMETER Path
	The path to the Private Key file.
	.OUTPUTS
	$True if the Private Key is detected to be encrypted.
	$False otherwise.
	.NOTES
	Author:		Matthew Schacherbauer
	Updated:	2019-06-30
		
	Version:	1.3
	.LINK
	https://github.com/matthewschacherbauer
	https://www.matthewschacherbauer.com
	#>

	[CmdletBinding()]
	Param (
		[ValidateScript({Test-Path -Path $_})]
		[string]		$OpenSslPath	= $ENV:OpenSsl + "\bin\openssl.exe",

		# Source Data
		[Parameter(Mandatory,ParameterSetName="Path")]
		[ValidateScript({Test-Path -Path $_})]
		[string]		$Path
	)

	# For PFX files, use OpenSSL to parse the private key.
	if ((Get-Item -Path $Path -ErrorAction SilentlyContinue).Extension -eq ".pfx") {
		$sResult = CMD.EXE /C "`"$($OpenSslPath)`" pkcs12 -in `"$($Path)`" -cacerts -nokeys -noout -passin pass:" '2>&1'
		if ($sResult -like "Mac verify error*") {
			return $true
		}
	}

	# For all other types, attempt to read the key text for ENCRYPTED in the string.
	else {
		if (Test-Path -Path $Path -ErrorAction SilentlyContinue) {
			$sKey = Get-Content -Path $Path
		}
		else {
			Throw "No Private Key data to parse."
		}

		if ($sKey -like "*ENCRYPTED*") {
			return $true
		}
	}

	return $false
}


Function Protect-PrivateKey {
	<#
	.SYNOPSIS
	Adds encryption to a Private Key
	.PARAMETER Rsa
	Specifies that RSA (PKCS1) encryption format should be used.
	.NOTES
	Author:		Matthew Schacherbauer
	Updated:	2019-06-30
	.LINK
	https://github.com/matthewschacherbauer
	https://www.matthewschacherbauer.com
	#>

	[CmdletBinding()]
	Param (
		[ValidateScript({Test-Path -Path $_})]
		[string]		$OpenSslPath	= $ENV:OpenSsl + "\bin\openssl.exe",

		# Encryption Option
		[Parameter(Mandatory)]
		[Securestring]	$Passphrase,

		# Format
		[switch]		$Rsa,

		# Source Files
		[Parameter(Mandatory)]
		$Path,

		# Output Files
		[Parameter(Mandatory)]
		$OutKey
	)

	# Decode Secure String
	$sPassphrase = Unprotect-SecureString -SecureString $Passphrase

	if ($Rsa) {
		# PKCS1
		# Encrypt with AES256
		$sCmd = "`"$($OpenSslPath)`" rsa -aes256 -passin pass: -passout pass:$sPassphrase -in `"$($Path)`" -out `"$($OutKey)`""
	}
	else {
		# PKCS8
		# Encrypt with AES256 with hmacWithSHA256
		# https://www.openssl.org/docs/man1.1.0/man1/openssl-pkcs8.html
		$sCmd = "`"$($OpenSslPath)`" pkcs8 -topk8 -v2 aes-256-cbc -passin pass: -passout pass:$sPassphrase -in `"$($Path)`" -out `"$($OutKey)`""
	}

	# Execute Command
	Write-Verbose "Executing Command: $($sCmd)"
	$sResult = CMD.EXE /C $sCmd '2>&1'

	# TODO: Capture and parse OpenSSL response.
	if ($?) { Write-Verbose ($sResult | Out-String) }
	else { Throw ($sResult | Out-String) }

	return (Get-Item -Path $OutKey)
}


Function Unprotect-PrivateKey {
	<#
	.SYNOPSIS
	Removes encryption from a Private Key
	.PARAMETER Rsa
	Specifies that RSA (PKCS1) encryption format should be used.
	.NOTES
	Author:		Matthew Schacherbauer
	Updated:	2019-06-30
	.LINK
	https://github.com/matthewschacherbauer
	https://www.matthewschacherbauer.com
	#>

	[CmdletBinding()]
	Param (
		[ValidateScript({Test-Path -Path $_})]
		[string]		$OpenSslPath	= $ENV:OpenSsl + "\bin\openssl.exe",

		# Encryption Option
		[Parameter(Mandatory)]
		[Securestring]	$Passphrase,

		# Format
		[switch]		$Rsa,

		# Source Files
		[Parameter(Mandatory)]
		$Path,

		# Output Files
		[Parameter(Mandatory)]
		$OutKey
	)

	# Decode Secure String
	$sPassphrase = Unprotect-SecureString -SecureString $Passphrase

	if ($Rsa) {
		# PKCS1
		# Strip app encryption
		$sCmd = "`"$($OpenSslPath)`" rsa -passin pass:$sPassphrase -in `"$($Path)`" -out `"$($OutKey)`""
	}
	else {
		# PKCS8
		# Strip app encryption
		# https://www.openssl.org/docs/man1.1.0/man1/openssl-pkcs8.html
		$sCmd = "`"$($OpenSslPath)`" pkcs8 -topk8 -nocrypt -passin pass:$sPassphrase -passout pass: -in `"$($Path)`" -out `"$($OutKey)`""
	}

	# Execute Command
	Write-Verbose "Executing Command: $($sCmd)"
	$sResult = CMD.EXE /C $sCmd '2>&1'

	# TODO: Capture and parse OpenSSL response.
	if ($?) { Write-Verbose ($sResult | Out-String) }
	else { Throw ($sResult | Out-String) }

	return (Get-Item -Path $OutKey)
}


Function Unprotect-SecureString {
	<#
	.SYNOPSIS
	Removes encryption from a SecureString variable and returns the encrypted password in plain text.
	.OUTPUTS
	String.
	.NOTES
	Author:		Matthew Schacherbauer
	Updated:	2019-06-30
	.LINK
	https://github.com/matthewschacherbauer
	https://www.matthewschacherbauer.com
	#>

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory,Position=0,ValueFromPipeline)]
		[securestring]	$SecureString
	)

	Begin {
		Write-Verbose "Call Unprotect-SecureString"
	}

	Process {
		# Decode Secure String
		$sSecureString = $SecureString | ConvertFrom-SecureString -ErrorAction Stop
		$sSecureString = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "NULL", ($sSecureString | ConvertTo-SecureString)
		$sSecureString = $sSecureString.GetNetworkCredential().Password

		$sSecureString
	}

	End { }
}


Function Remove-CertificateBagAttributes {
	<#
	.SYNOPSIS
	Removes Bag Attributes from a certificate.
	.NOTES
	Author:		Matthew Schacherbauer
	Updated:	2019-06-30
	.LINK
	https://github.com/matthewschacherbauer
	https://www.matthewschacherbauer.com
	#>

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory,Position=0,ValueFromPipeline)]
		$Certificate
	)

	Begin {
		Write-Verbose "Call Remove-CertificateBagAttributes"
	}

	Process {
		$Certificate | Where-Object {
			$_ -notlike "Bag Attributes*" -and `
			$_ -notlike "subject=*" -and `
			$_ -notlike "issuer=*" -and `
			$_ -notlike "" -and `
			$_ -notlike "    *" -and `
			$_ -notlike "Key *"
		}
	}

	End { }
}


Function ConvertTo-Der {
	<#
	.SYNOPSIS
	Converts various certificate formats to a DER certificate
	.NOTES
	Author:		Matthew Schacherbauer
	Updated:	2019-06-30
		
	Version:	2.0
	.LINK
	https://www.matthewschacherbauer.com
	#>

	[CmdletBinding()]
	Param (
		[ValidateScript({Test-Path -Path $_})]
		[string]		$OpenSslPath	= $ENV:OpenSsl + "\bin\openssl.exe",

		# Source Files
		[Parameter(Mandatory)]
		[ValidateSet("cer","crt","pem","x509","p7b","pkcs7")]
		[string]		$SourceFormat,
		[Parameter(Mandatory)]
		[ValidateScript({Test-Path -Path $_})]
		[string]		$Path,

		# Output Files
		[Parameter(Mandatory)]
		[string]		$OutPath
	)

	Write-Verbose "Call ConvertTo-Der"

	# Resolve Parameters
	if ($Path) { $oPath = Get-Item -Path $Path -ErrorAction Stop }
	if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

	# Variables
	$ENV:RANDFILE	= $ENV:USERPROFILE + "\.rnd"

	# Determine output file paths
	$sOutCert = $oOutPath.FullName + "\" + $oPath.BaseName + ".der"

	Switch ($SourceFormat) {
		{$_ -in "cer","crt","pem","x509"} { # .PEM
			$sCmd = "`"$($OpenSslPath)`" x509 -outform der -in `"$($oPath.FullName)`" -out `"$($sOutCert)`""
		}
		{$_ -in "p7b","pkcs7"} { #.P7B
			$sCmd = "`"$($OpenSslPath)`" pkcs7 -in `"$($oPath.FullName)`" -outform der -out `"$($sOutCert)`""
		}
		default { Throw "Unexpected Source Format" }
	}

	# Execute Command
	Write-Verbose "Executing Command: $($sCmd)"
	$sResult = CMD.EXE /C $sCmd '2>&1'

	# TODO: Capture and parse OpenSSL response.
	if ($?) { Write-Verbose ($sResult | Out-String) }
	else { Throw ($sResult | Out-String) }

	return (Get-Item -Path $sOutCert)
}


Function ConvertTo-JavaKeystore {
	<#
	.SYNOPSIS
	Converts a PFX formatted certificate to a Java Keystore format.
	.NOTES
	Author:		Matthew Schacherbauer
	Updated:	2019-06-30
		
	Version:	1.0

	The Java Keystore format requires a passphrase of at least six characters to be used.
	.LINK
	https://www.matthewschacherbauer.com
	https://www.openssl.org/docs/manmaster/man1/pkcs12.html
	#>

	[CmdletBinding()]
	Param (
		[ValidateScript({Test-Path -Path $_})]
		[string]		$OpenSslPath	= $ENV:OpenSsl + "\bin\openssl.exe",
		[Parameter(Mandatory)]
		[ValidateScript({Test-Path -Path $_})]
		[string]		$JavaPath		= $ENV:Java_Home,

		# Encryption Options
		[Parameter(Mandatory)]
		[securestring]	$Passphrase,

		# Source Files
		[Parameter(Mandatory)]
		[ValidateScript({Test-Path -Path $_})]
		[string]		$Path,

		# Output Files
		[Parameter(Mandatory)]
		[string]		$OutPath
	)

	Write-Verbose "Call ConvertTo-JavaKeystore"

	# Resolve Parameters
	if ($Path) { $oPath = Get-Item -Path $Path -ErrorAction Stop }
	if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

	# Variables
	$ENV:RANDFILE	= $ENV:USERPROFILE + "\.rnd"
	$JavaKeytool	= $JavaPath + "\bin\keytool.exe"

	# Determine output file paths
	$sOutCert = $oOutPath.FullName + "\" + $oPath.BaseName + ".ks"

	# Check for Keytool utility.
	if (!(Test-Path -Path $JavaKeytool -ErrorAction SilentlyContinue)) {
		Throw "Java keytool.exe not found at path: ($($JavaKeytool))."
	}

	# Validate source CertFile
	if (!(Get-Item -Path $oPath.FullName -ErrorAction SilentlyContinue).Extension -eq ".pfx") {
		Throw "Source CertFile must be of type PFX."
	}

	# Check for Encrypted Source PFX
	if (!(isEncryptedPrivateKey -OpenSslPath $OpenSslPath -Path $oPath.FullName)) {
		Throw "The source PFX file must be encrypted."
	}

	# Decode Passphrase
	Write-Verbose "Decoding passphrase."
	$sPassphrase = Unprotect-SecureString -SecureString $Passphrase	

	# Check passphrase length
	if ($sPassphrase.length -lt 6) { Throw "Passphrase length is not sufficient." }

	# Build the command line
	Write-Verbose "Building Java command."

	$sCmd = "`"$($JavaKeytool)`" -importkeystore -srckeystore `"$($oPath.FullName)`" -srcstoretype pkcs12 -srcstorepass `"$($sPassphrase)`" -destkeystore `"$($sOutCert)`" -deststoretype JKS -deststorepass `"$($sPassphrase)`""

	# Execute Command
	Write-Verbose "Executing Command: $($sCmd)"
	$sResult = CMD.EXE /C $sCmd '2>&1'

	# TODO: Capture and parse keytool response.
	if ($?) { Write-Verbose ($sResult | Out-String) }
	else { Throw ($sResult | Out-String) }

	# Return Data
	return [PrivateKey] @{
		"Encrypted"		= $True
		"Passphrase"	= $Passphrase
		"Path"			= $( if ($sOutCert) { Get-Item -Path $sOutCert } )
	}
}


Function ConvertTo-Pem {
	<#
	.SYNOPSIS
	Converts various certificate formats to a PEM certificate.
	.NOTES
	Author:		Matthew Schacherbauer
	Updated:	2019-06-30
		
	Version:	2.0
	.LINK
	https://www.matthewschacherbauer.com
	#>

	[CmdletBinding()]
	Param (
		[ValidateScript({Test-Path -Path $_})]
		[string]		$OpenSslPath	= $ENV:OpenSsl + "\bin\openssl.exe",

		# Source Files
		[Parameter(Mandatory)]
		[ValidateSet("cer","crt","pem","x509","p7b","pkcs7")]
		[string]		$SourceFormat,
		[Parameter(Mandatory)]
		[ValidateScript({Test-Path -Path $_})]
		[string]		$Path,

		# Output Files
		[Parameter(Mandatory)]
		[string]		$OutPath
	)

	Write-Verbose "Call ConvertTo-Pem"

	# Resolve Parameters
	if ($Path) { $oPath = Get-Item -Path $Path -ErrorAction Stop }
	if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

	# Variables
	$ENV:RANDFILE	= $ENV:USERPROFILE + "\.rnd"

	# Determine output file paths
	$sOutCert = $oOutPath.FullName + "\" + $oPath.BaseName + ".pem"

	Switch ($SourceFormat) {
		{$_ -in "cer","crt","pem","x509"} { # .CRT
			$sCmd = "`"$($OpenSslPath)`" x509 -in `"$($oPath.FullName)`" -out `"$($sOutCert).tmp`""
		}
		{$_ -in "p7b","pkcs7"} { # .P7B
			$sCmd = "`"$($OpenSslPath)`" pkcs7 -print_certs -in `"$($oPath.FullName)`" -outform pem -out `"$($sOutCert).tmp`""
		}
		default { Throw "Unexpected Source Format" }
	}

	# Execute Command
	Write-Verbose "Executing Command: $($sCmd)"
	$sResult = CMD.EXE /C $sCmd '2>&1'

	# TODO: Capture and parse OpenSSL response.
	if ($?) { Write-Verbose ($sResult | Out-String) }
	else { Throw ($sResult | Out-String) }

	Get-Content "$($sOutCert).tmp" | Remove-CertificateBagAttributes | Set-Content "$($sOutCert)" -Encoding ASCII
	Remove-Item "$($sOutCert).tmp"

	return (Get-Item -Path $sOutCert)
}


Function ConvertTo-Pfx {
	<#
	.SYNOPSIS
	Converts various certificate formats to a PFX certificate
	.NOTES
	Author:		Matthew Schacherbauer
	Updated:	2019-06-30
		
	Version:	2.0
	.LINK
	https://www.matthewschacherbauer.com
	https://www.openssl.org/docs/manmaster/man1/pkcs12.html
	#>

	[CmdletBinding()]
	Param (
		[ValidateScript({Test-Path -Path $_})]
		[string]		$OpenSslPath	= $ENV:OpenSsl + "\bin\openssl.exe",

		# Encryption Options
		[securestring]	$Passphrase,
		[switch]		$Encrypt,
		[ValidateSet('aes128','aes192','aes256','aria128','aria192','aris256','camellia128','camellia192','camellia256','des3')]
		[string]		$Cipher			= "aes256",

		# Source Files
		[Parameter(Mandatory)]
		[ValidateScript({Test-Path -Path $_})]
		[string]		$Certificate,
		[Parameter(Mandatory)]
		[ValidateScript({Test-Path -Path $_})]
		[string]		$Key,

		# Output Files
		[Parameter(Mandatory)]
		[string]		$OutPath
	)

	Write-Verbose "Call ConvertTo-Pfx"

	# Resolve Parameters
	if ($Certificate) { $oCertificate = Get-Item -Path $Certificate -ErrorAction Stop }
	if ($Key) { $oKey = Get-Item -Path $Key -ErrorAction Stop }
	if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

	# Variables
	$ENV:RANDFILE	= $ENV:USERPROFILE + "\.rnd"

	# Determine output file paths
	$sOutCertificate = $oOutPath.FullName + "\" + $oCertificate.BaseName + ".pfx"

	# Check for Encrypted Private Key
	if (!$Encrypt -and (isEncryptedPrivateKey -OpenSslPath $OpenSslPath -Path $oKey.FullName)) {
		Write-Verbose "Detected encrypted private key without encryption declared."
		$Encrypt = $true
	}

	# Check Encryption
	if ($Encrypt) {
		if (!$Passphrase) {
			Write-Verbose "Encryption requested without a supplied passphrase."
			$Passphrase = Read-Host "Private Key Passphrase" -AsSecureString
		}
		
		# Decode Passphrase
		Write-Verbose "Decoding passphrase."
		$sPassphrase = Unprotect-SecureString -SecureString $Passphrase	
	}

	# Build the command line
	Write-Verbose "Building OpenSSL command."

	$sCmd = "`"$($OpenSslPath)`" pkcs12 -export -in `"$($oCertificate.FullName)`" -inkey `"$($oKey.FullName)`" -out `"$($sOutCertificate)`""

	if ($Encrypt) {
		Write-Verbose "Use encrypted private key."
		$sCmd += " -passin pass:`"$($sPassphrase)`" -passout pass:`"$($sPassphrase)`" -$($Cipher)"
	}
	else {
		Write-Verbose "Use plaintext private key."
		$sCmd += " -nodes -passout pass:"
	}

	# Execute Command
	Write-Verbose "Executing Command: $($sCmd)"
	$sResult = CMD.EXE /C $sCmd '2>&1'

	# TODO: Capture and parse OpenSSL response.
	if ($?) { Write-Verbose ($sResult | Out-String) }
	else { Throw ($sResult | Out-String) }

	# Return Data
	return [PrivateKey] @{
		"Encrypted"		= $Encrypt
		"Passphrase"	= $Passphrase
		"Path"			= $( if ($sOutCertificate) { Get-Item -Path $sOutCertificate } )
	}
}


Function ConvertTo-Pkcs1 {
	<#
	.SYNOPSIS
	Converts a PCKS8 Private Key to PKCS1
	.NOTES
	Author:		Matthew Schacherbauer
	Updated:	2019-06-30
		
	Version:	2.0
	.LINK
	https://www.matthewschacherbauer.com
	https://www.openssl.org/docs/manmaster/man1/rsa.html
	#>

	[CmdletBinding()]
	Param (
		[ValidateScript({Test-Path -Path $_})]
		[string]		$OpenSslPath	= $ENV:OpenSsl + "\bin\openssl.exe",

		# Encryption Options
		[securestring]	$Passphrase,
		[switch]		$Encrypt,
		[ValidateSet('aes128','aes192','aes256','aria128','aria192','aris256','camellia128','camellia192','camellia256','des3')]
		[string]		$Cipher			= "aes256",

		# Source Files
		[Parameter(Mandatory)]
		[ValidateScript({Test-Path -Path $_})]
		[string]		$Path,

		# Output Files
		[string]		$OutPath
	)

	Write-Verbose "Call ConvertTo-Pkcs1"

	# Resolve Parameters
	if ($Path) { $oPath = Get-Item -Path $Path -ErrorAction Stop }
	if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

	# Variables
	$ENV:RANDFILE	= $ENV:USERPROFILE + "\.rnd"

	# Determine output file paths
	$sOutKey = $oOutPath.FullName + "\" + $oPath.BaseName + ".pkcs1.key"

	# Check for Encrypted Private Key
	if (!$Encrypt -and (isEncryptedPrivateKey -OpenSslPath $OpenSslPath -Path $oPath.FullName)) {
		Write-Verbose "Detected encrypted private key without encryption declared."
		$Encrypt = $true
	}

	# Check Encryption
	if ($Encrypt) {
		if (!$Passphrase) {
			Write-Verbose "Encryption requested without a supplied passphrase."
			$Passphrase = Read-Host "Private Key Passphrase" -AsSecureString
		}
		
		# Decode Passphrase
		Write-Verbose "Decoding passphrase."
		$sPassphrase = Unprotect-SecureString -SecureString $Passphrase	
	}

	# Build the command line
	Write-Verbose "Building OpenSSL command."

	$sCmd = "`"$($OpenSslPath)`" rsa -in `"$($oPath.FullName)`""

	if ($Encrypt) {
		Write-Verbose "Use encrypted private key."
		$sCmd += " -passin pass:`"$($sPassphrase)`" -passout pass:`"$($sPassphrase)`" -$($Cipher)"
	}
	else {
		Write-Verbose "Use plaintext private key."
		#$sCmd += ""
	}

	Write-Verbose "Write data to file."
	$sCmd += " -out `"$($sOutKey)`""

	# Execute Command
	Write-Verbose "Executing Command: $($sCmd)"
	$sResult = CMD.EXE /C $sCmd '2>&1'

	# TODO: Capture and parse OpenSSL response.
	if ($?) { Write-Verbose ($sResult | Out-String) }
	else { Throw ($sResult | Out-String) }

	# Return Data
	return [PrivateKey] @{
		"Encrypted"		= $Encrypt
		"Passphrase"	= $Passphrase
		"Path"			= $( if ($sOutKey) { Get-Item -Path $sOutKey } )
	}
}


Function ConvertTo-Pkcs8 {
	<#
	.SYNOPSIS
	Converts a PKCS1 Private Key to PKCS8
	.NOTES
	Author:		Matthew Schacherbauer
	Updated:	2019-06-30
		
	Version:	2.0
	.LINK
	https://www.matthewschacherbauer.com
	https://www.openssl.org/docs/man1.0.2/man1/openssl-pkcs8.html
	#>

	[CmdletBinding()]
	Param (
		[ValidateScript({Test-Path -Path $_})]
		[string]		$OpenSslPath	= $ENV:OpenSsl + "\bin\openssl.exe",

		# Encryption Options
		[securestring]	$Passphrase,
		[switch]		$Encrypt,

		# Source Files
		[Parameter(Mandatory)]
		[ValidateScript({Test-Path -Path $_})]
		[string]		$Path,

		# Output Files
		[string]		$OutPath
	)

	Write-Verbose "Call ConvertTo-Pkcs8"

	# Resolve Parameters
	if ($Path) { $oPath = Get-Item -Path $Path -ErrorAction Stop }
	if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

	# Variables
	$ENV:RANDFILE	= $ENV:USERPROFILE + "\.rnd"

	# Determine output file paths
	$sOutKey = $oOutPath.FullName + "\" + $oPath.BaseName + ".pkcs8.key"

	# Check for Encrypted Private Key
	if (!$Encrypt -and (isEncryptedPrivateKey -OpenSslPath $OpenSslPath -Path $oPath.FullName)) {
		Write-Verbose "Detected encrypted private key without encryption declared."
		$Encrypt = $true
	}

	# Check Encryption
	if ($Encrypt) {
		if (!$Passphrase) {
			Write-Verbose "Encryption requested without a supplied passphrase."
			$Passphrase = Read-Host "Private Key Passphrase" -AsSecureString
		}
		
		# Decode Passphrase
		Write-Verbose "Decoding passphrase."
		$sPassphrase = Unprotect-SecureString -SecureString $Passphrase	
	}

	# Build the command line
	Write-Verbose "Building OpenSSL command."

	$sCmd = "`"$($OpenSslPath)`" pkcs8 -topk8 -in `"$($oPath.FullName)`""

	if ($Encrypt) {
		Write-Verbose "Use encrypted private key."
		$sCmd += " -passin pass:`"$($sPassphrase)`" -passout pass:`"$($sPassphrase)`" -v2 des3 -v2prf hmacWithSHA256"
	}
	else {
		Write-Verbose "Use plaintext private key."
		$sCmd += " -nocrypt"
	}

	Write-Verbose "Write data to file."
	$sCmd += " -out `"$($sOutKey)`""

	# Execute Command
	Write-Verbose "Executing Command: $($sCmd)"
	$sResult = CMD.EXE /C $sCmd '2>&1'

	# TODO: Capture and parse OpenSSL response.
	if ($?) { Write-Verbose ($sResult | Out-String) }
	else { Throw ($sResult | Out-String) }

	# Return Data
	return [PrivateKey] @{
		"Encrypted"		= $Encrypt
		"Passphrase"	= $Passphrase
		"Path"			= $( if ($sOutKey) { Get-Item -Path $sOutKey } )
	}
}


Function Export-CaChain {
	<#
	.SYNOPSIS
	Exports a certificate authority chain file from a source certificate.
	Essentially, spits out only the parents of a given certificate.
	.NOTES
	Author:		Matthew Schacherbauer
	Updated:	2019-06-30
		
	Version:	2.0
	.LINK
	https://www.matthewschacherbauer.com
	#>

	[CmdletBinding()]
	Param (
		[ValidateScript({Test-Path -Path $_})]
		[string]		$OpenSslPath	= $ENV:OpenSsl + "\bin\openssl.exe",

		# Encryption Options
		[securestring]	$Passphrase,
		[switch]		$Encrypt,

		# Source Files
		[Parameter(Mandatory)]
		[ValidateSet("pfx","pkcs12")]
		$SourceFormat,
		[Parameter(Mandatory)]
		[ValidateScript({Test-Path -Path $_})]
		$Path,

		# Output Files
		[Parameter(Mandatory)]
		$OutPath
	)

	Write-Verbose "Call Export-CaChain"

	# Resolve Parameters
	if ($Path) { $oPath = Get-Item -Path $Path -ErrorAction Stop }
	if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

	# Variables
	$ENV:RANDFILE	= $ENV:USERPROFILE + "\.rnd"

	# Determine output file paths
	$sOutFile = "$($oOutPath.FullName)" + "\" + "cachain.pem"

	# Check for Encrypted Private Key
	if (!$Encrypt -and (isEncryptedPrivateKey -OpenSslPath $OpenSslPath -Path $oPath.FullName)) {
		Write-Verbose "Detected encrypted private key without encryption declared."
		$Encrypt = $true
	}

	# Check Encryption
	if ($Encrypt) {
		if (!$Passphrase) {
			Write-Verbose "Encryption requested without a supplied passphrase."
			$Passphrase = Read-Host "Private Key Passphrase" -AsSecureString
		}
		
		# Decode Passphrase
		Write-Verbose "Decoding passphrase."
		$sPassphrase = Unprotect-SecureString -SecureString $Passphrase

		$encryptString = " -passin pass:$($sPassphrase) -passout pass:$($sPassphrase)"
	}
	else {
		Write-Verbose "Use plaintext private key."
		$encryptString = " -nodes -passin pass:"
	}

	Switch ($SourceFormat) {
		{$_ -in "pfx","pkcs12"} { # .PFX
			$sCmd = "`"$($OpenSslPath)`" pkcs12 -in `"$($oPath.FullName)`" -cacerts -nokeys $($encryptString) -out `"$($sOutFile).tmp`""
		}
		default { Throw "Unexpected Source Format" }
	}

	# Execute Command
	Write-Verbose "Executing Command: $($sCmd)"
	$sResult = CMD.EXE /C $sCmd '2>&1'

	# TODO: Capture and parse keytool response.
	if ($?) { Write-Verbose ($sResult | Out-String) }
	else { Throw ($sResult | Out-String) }

	if ( (Get-Item "$($sOutFile).tmp").length -eq 0) {
		Write-Error "No CA Chain file was exported! Verify that the certificate chain contains at least one parent certificate."
		Remove-Item "$($sOutFile).tmp"
		return
	}

	Get-Content "$($sOutFile).tmp" | Remove-CertificateBagAttributes | Set-Content "$($sOutFile)" -Encoding ASCII
	Remove-Item "$($sOutFile).tmp"

	# Return Data
	return (Get-Item -Path $sOutFile)
}


Function New-OpenSslCertificateConfiguration {
	<#
	.SYNOPSIS
	Creates a configuration file for a new RSA Public/Private KeyPair.
	.NOTES
	Author:		Matthew Schacherbauer
	Updated:	2019-04-22
		
	Version:	1.2
	.LINK
	https://www.matthewschacherbauer.com
	#>

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory)]
		[string[]]	$Hostname,
		[ValidateSet('1024','2048','3072','4096')]
		[int]		$Bits				= "4096",

		# Encryption Options
		[switch]	$Encrypt,

		# Distinguished Name
		[Parameter(Mandatory)]
		[string]	$CountryName,
		[Parameter(Mandatory)]
		[string]	$State,
		[Parameter(Mandatory)]
		[string]	$Locality,
		[string]	$PostalCode,
		[string]	$StreetAddress,
		[Parameter(Mandatory)]
		[string]	$Organization,
		[Parameter(Mandatory)]
		[string]	$OrganizationalUnitName,
		[string]	$Email
	)

	Write-Verbose "Call New-OpenSslCertificateConfiguration"

	# Format the SAN attribute
	foreach ($thisHost in $Hostname) {
		if ($sanList) { $sanList += "," }
		$sanList += "DNS:$($thisHost)"
	}

	# Format the encryption value
	if ($Encrypt) { $sEncrypt = "yes" }
	else { $sEncrypt = "no" }

	$config = "# OpenSSL configuration to generate a new key with signing request for a x509v3
# multidomain certificate

[ req ]
default_bits       = $($Bits)
default_md         = sha512
prompt             = no
encrypt_key        = $($sEncrypt)
#string_mask       = nombstr

# base request
distinguished_name = req_distinguished_name

# extensions
req_extensions     = v3_req

# distinguished_name
[ req_distinguished_name ]
countryName            = `"$($CountryName)`"             # C=
stateOrProvinceName    = `"$($State)`"                   # ST=
localityName           = `"$($Locality)`"                # L=
$( if (!$PostalCode) { "#" } )postalCode            = `"$($PostalCode)`"              # L/postalcode=
$( if (!$StreetAddress) { "#" } )streetAddress         = `"$($StreetAddress)`"           # L/street=
organizationName       = `"$($Organization)`"            # O=
organizationalUnitName = `"$($OrganizationalUnitName)`"  # OU=
commonName             = `"$($Hostname[0])`"             # CN=
$( if (!$Email) { "#" } )emailAddress           = `"$($Email)`"                   # CN/emailAddress=

# req_extensions
[ v3_req ]
# Key Restrictions
basicConstraints       = CA:false
keyUsage               = digitalSignature, keyEncipherment
extendedKeyUsage       = serverAuth, clientAuth

# The subject alternative name extension allows various literal values to be 
# included in the configuration file
# http://www.openssl.org/docs/apps/x509v3_config.html
subjectAltName  = $($sanList)"

	return $config
}


Function New-CertificateSigningRequest {
	<#
	.SYNOPSIS
	Generates a new private key and PKCS10 certificate signing request
	.NOTES
	Author:		Matthew Schacherbauer
	Updated:	2019-06-29
		
	Version:	2.0
	.LINK
	https://www.matthewschacherbauer.com
	https://www.openssl.org/docs/manmaster/man1/req.html
	#>

	[CmdletBinding()]
	Param (
		[ValidateScript({Test-Path -Path $_})]
		[string]		$OpenSslPath	= $ENV:OpenSsl + "\bin\openssl.exe",

		# Certificate Options
		[Parameter(ParameterSetName="ConfigIn")]
		[string]		$Config,
		[Parameter(Mandatory,Position=0)]
		[string[]]		$Hostname,
		[Parameter(ParameterSetName="ConfigGen")]
		[ValidateSet('1024','2048','3072','4096')]
		[int]			$Bits			= "4096",
		[Parameter(ParameterSetName="ConfigGen")]
		[string]		$CountryName	= "US",
		[Parameter(ParameterSetName="ConfigGen")]
		[string]		$State			= "California",
		[Parameter(ParameterSetName="ConfigGen")]
		[string]		$Locality		= "Sacramento",
		[Parameter(ParameterSetName="ConfigGen")]
		[string]		$PostalCode,
		[Parameter(ParameterSetName="ConfigGen")]
		[string]		$StreetAddress,
		[Parameter(ParameterSetName="ConfigGen")]
		[string]		$Organization	= "WolfSpiritNet",
		[Parameter(ParameterSetName="ConfigGen")]
		[string]		$OrganizationalUnitName	= "Test Lab",
		[Parameter(ParameterSetName="ConfigGen")]
		[string]		$Email,

		# Encryption Options
		[securestring]	$Passphrase,
		[switch]		$Encrypt,

		# Output Options
		[Parameter(Mandatory)]
		[string]		$OutPath
	)

	Write-Verbose "Call New-CertificateSigningRequest"

	# Resolve Parameters
	if ($Config) { $oConfig = Get-Item -Path $Config -ErrorAction Stop }
	if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

	# Variables
	$ENV:RANDFILE	= $ENV:USERPROFILE + "\.rnd"

	# Determine output file paths
	$sOutKey = $oOutPath.FullName + "\" + $Hostname[0] + ".key"
	$sOutRequest = $oOutPath.FullName + "\" + $Hostname[0] + ".csr"

	# Check Encryption
	if ($Encrypt) {
		if (!$Passphrase) {
			Write-Verbose "Encryption requested without a supplied passphrase."
			$Passphrase = Read-Host "Private Key Passphrase" -AsSecureString
		}
		
		# Decode Passphrase
		Write-Verbose "Decoding passphrase."
		$sPassphrase = Unprotect-SecureString -SecureString $Passphrase	
	}

	# Import or generate a request configuration file
	if ($oConfig) {
		Write-Verbose "Using input OpenSSL configuration file: $($oConfig.FullName)"
	}
	else {
		$sConfig = $oOutPath.FullName + "\" + $Hostname[0] + ".cfg"
		Write-Verbose "Generating new OpenSSL configuration file with input parameters. Using path: $($sConfig)"
		New-OpenSslCertificateConfiguration `
			-Hostname $Hostname `
			-CountryName $CountryName `
			-State $State `
			-Locality $Locality `
			-PostalCode $PostalCode `
			-StreetAddress $StreetAddress `
			-Organization $Organization `
			-OrganizationalUnitName $OrganizationalUnitName `
			-Email $Email `
			-Bits $Bits `
			-Encrypt:$Encrypt `
			-ErrorAction Stop |
			Out-File -FilePath $sConfig -Encoding ASCII -ErrorAction Stop
		$oConfig = Get-Item -Path $sConfig -ErrorAction Stop
	}

	# Build the command line
	Write-Verbose "Building OpenSSL command."
	$sCmd = "`"$($OpenSslPath)`" req -new -newkey rsa:$($Bits) -config `"$($oConfig.FullName)`""

	if ($Encrypt) {
		Write-Verbose "Generate private key with encryption."
		$sCmd += " -passout pass:`"$($sPassphrase)`""
	}
	else {
		Write-Verbose "Generate private key without encryption."
		$sCmd += " -nodes"
	}

	Write-Verbose "Write data to file."
	$sCmd += " -keyout `"$($sOutKey)`" -out `"$($sOutRequest)`""

	# Execute Command
	Write-Verbose "Executing Command: $($sCmd)"
	$sResult = CMD.EXE /C $sCmd '2>&1'

	# TODO: Capture and parse OpenSSL response.
	if ($?) { Write-Verbose ($sResult | Out-String) }
	else { Throw ($sResult | Out-String) }

	# Return Data
	return [PSCustomObject] @{
		"PrivateKey"				= [PrivateKey] @{
			"Encrypted"				= $Encrypt
			"Passphrase"			= $Passphrase
			"Path"					= $( if ($sOutKey) { Get-Item -Path $sOutKey } )
		}

		"CertificateRequest"		= [PSCustomObject] @{
			"Config"				= $oConfig
			"Path"					= $( if ($sOutRequest) { Get-Item -Path $sOutRequest } )
		}
	}
}


Function New-SelfSignedCertificate {
	<#
	.SYNOPSIS
	Generates a self signed certificate using a provate key and certificate signing request file.
	.NOTES
	Author:		Matthew Schacherbauer
	Updated:	2019-06-29
		
	Version:	2.0
	.LINK
	https://www.matthewschacherbauer.com
	https://www.openssl.org/docs/manmaster/man1/x509.html
	#>

	[CmdletBinding()]
	Param (
		[ValidateScript({Test-Path -Path $_})]
		[string]		$OpenSslPath	= $ENV:OpenSsl + "\bin\openssl.exe",

		# Options
		[Parameter(Mandatory)]
		[int]			$ValidityDays,

		# Encryption Options
		[securestring]	$Passphrase,
		[switch]		$Encrypt,

		# Source Files
		[Parameter(Mandatory)]
		[ValidateScript({Test-Path -Path $_})]
		[string]		$Config,
		[Parameter(Mandatory)]
		[ValidateScript({Test-Path -Path $_})]
		[string]		$Key,
		[Parameter(Mandatory)]
		[ValidateScript({Test-Path -Path $_})]
		[string]		$Request,

		# Output Files
		[Parameter(Mandatory)]
		[string]		$OutPath
	)

	Write-Verbose "Call New-SelfSignedCertificate"

	# Resolve Parameters
	if ($Config) { $oConfig = Get-Item -Path $Config -ErrorAction Stop }
	if ($Key) { $oKey = Get-Item -Path $Key -ErrorAction Stop }
	if ($Request) { $oRequest = Get-Item -Path $Request -ErrorAction Stop }
	if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

	# Variables
	$ENV:RANDFILE	= $ENV:USERPROFILE + "\.rnd"

	# Determine output file paths
	$sOutCert = $oOutPath.FullName + "\" + $oRequest.BaseName + ".selfsigned.crt"
	$sOutCertChain = $oOutPath.FullName + "\" + $oRequest.BaseName + ".selfsigned.chain.p7b"

	# Check for Encrypted Private Key
	if (!$Encrypt -and (isEncryptedPrivateKey -OpenSslPath $OpenSslPath -Path $oKey.FullName)) {
		Write-Verbose "Detected encrypted private key without encryption declared."
		$Encrypt = $true
	}

	# Check Encryption
	if ($Encrypt) {
		if (!$Passphrase) {
			Write-Verbose "Encryption requested without a supplied passphrase."
			$Passphrase = Read-Host "Private Key Passphrase" -AsSecureString
		}
		
		# Decode Passphrase
		Write-Verbose "Decoding passphrase."
		$sPassphrase = Unprotect-SecureString -SecureString $Passphrase	
	}

	# Build the command line
	Write-Verbose "Building OpenSSL command."

	$sCmd = "`"$($OpenSslPath)`" x509 -signkey `"$($oKey.FullName)`" -req -days $($ValidityDays) -extfile `"$($oConfig.FullName)`" -extensions v3_req -in `"$($oRequest.FullName)`""

	if ($Encrypt) {
		Write-Verbose "Use encrypted private key."
		$sCmd += " -passin pass:`"$($sPassphrase)`""
	}
	else {
		Write-Verbose "Use plaintext private key."
		#$sCmd += ""
	}

	Write-Verbose "Write data to file."
	$sCmd += " -out `"$($sOutCert)`""

	# Execute Command
	Write-Verbose "Executing Command: $($sCmd)"
	$sResult = CMD.EXE /C $sCmd '2>&1'

	# TODO: Capture and parse OpenSSL response.
	if ($?) { Write-Verbose ($sResult | Out-String) }
	else { Throw ($sResult | Out-String) }

	# Convert the resulting cert to P7B
	Write-Verbose "Converting the resulting certificate to an empty chain."
	$sCmd = "`"$($OpenSslPath)`" crl2pkcs7 -nocrl -certfile `"$($sOutCert)`" -out `"$($sOutCertChain)`""

	# Execute Command
	Write-Verbose "Executing Command: $($sCmd)"
	$sResult = CMD.EXE /C $sCmd '2>&1'

	# TODO: Capture and parse OpenSSL response.
	if ($?) { Write-Verbose ($sResult | Out-String) }
	else { Throw ($sResult | Out-String) }

	# Return Data
	return [PSCustomObject] @{
		"PrivateKey"			= [PrivateKey] @{
			"Encrypted"			= $Encrypt
			"Passphrase"		= $Passphrase
			"Path"				= $oKey
		}

		"Certificate"			= $( if ($sOutCert) { Get-Item -Path $sOutCert } )
		"CertificateChain"		= $( if ($sOutCertChain) { Get-Item -Path $sOutCertChain } )
	}
}


Function New-EnterpriseCertificateAuthoritySignature {
	<#
	.SYNOPSIS
	Submits a certificate signing request to an Active Directory Certificate Authority
	.NOTES
	Author:		Matthew Schacherbauer
	Updated:	2019-06-30
		
	Version:	2.0
	.LINK
	https://www.matthewschacherbauer.com
	#>

	[CmdletBinding()]
	Param (
		# Options
		[Parameter(Mandatory)]
		[string]		$AdcsTemplate,
		[Parameter(Mandatory)]
		[string]		$AdcsServer,

		# Source Files
		[Parameter(Mandatory)]
		[ValidateScript({Test-Path -Path $_})]
		[string]		$Path,

		# Output Files
		[Parameter(Mandatory)]
		[string]		$OutPath
	)

	Write-Verbose "Call New-EnterpriseCertificateAuthoritySignature"

	# Resolve Parameters
	if ($Path) { $oPath = Get-Item -Path $Path -ErrorAction Stop }
	if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

	# Determine output file paths
	$sOutCert = $oOutPath.FullName + "\" + $oPath.BaseName + ".crt"
	$sOutChainP7b = $oOutPath.FullName + "\" + $oPath.BaseName + ".chain.p7b"
	$sOutChainRsp = $oOutPath.FullName + "\" + $oPath.BaseName + ".chain.rsp"

	# Submit CertReq to Certificate Authority.
	$sResult = CMD.EXE /C "`"$ENV:WINDIR\System32\CERTREQ.EXE`" -attrib `"CertificateTemplate:$($AdcsTemplate)`" -config `"$($AdcsServer)`" -submit `"$($oPath.FullName)`" `"$($sOutCert)`" `"$($sOutChainP7b)`" `"$($sOutChainRsp)`"" '2>&1'

	# TODO: Capture and parse CertReq response.
	if ($?) { Write-Verbose ($sResult | Out-String) }
	else { Throw ($sResult | Out-String) }

	# Return Data
	return [PSCustomObject] @{
		"AdcsTemplate"			= $AdcsTemplate
		"AdcsServer"			= $AdcsServer

		"Certificate"			= [PSCustomObject] @{
			"CRT"				= $( if ($sOutCert) { Get-Item -Path $sOutCert } )
		}

		"CertificateChain"		= [PSCustomObject] @{
			"P7B"				= $( if ($sOutChainP7b) { Get-Item -Path $sOutChainP7b } )
			"RSP"				= $( if ($sOutChainRsp) { Get-Item -Path $sOutChainRsp } )
		}
	}
}


Function Complete-CertificateSigningRequest {
	<#
	.SYNOPSIS
	Completes a new certificate signing request with the signed certificate file from an issuing Certificate Authority.
	.NOTES
	Author:		Matthew Schacherbauer
	Updated:	2019-06-30

	Version:	1.0
	.LINK
	https://www.matthewschacherbauer.com
	#>

	[CmdletBinding()]
	Param (
		[ValidateScript({Test-Path -Path $_})]
		[string]		$OpenSslPath	= $ENV:OpenSsl + "\bin\openssl.exe",
		[ValidateScript({Test-Path -Path $_})]
		[string]		$JavaPath		= $ENV:Java_Home,

		# Encryption Options
		[securestring]	$Passphrase,
		[switch]		$Encrypt,

		# Source Files
		[ValidateScript({Test-Path $_ })]
		[string]		$Certificate,
		[Parameter(Mandatory)]
		[ValidateScript({Test-Path $_ })]
		[string]		$CertificateChain,
		[Parameter(Mandatory)]
		[ValidateScript({Test-Path $_ })]
		[string]		$Key,

		# Output Files
		[string]		$OutPath
	)

	Write-Verbose "Call Complete-CertificateSigningRequest"

	# Resolve Parameters
	if ($Certificate) { $oCertificate = Get-Item -Path $Certificate -ErrorAction Stop }
	if ($CertificateChain) { $oCertificateChain = Get-Item -Path $CertificateChain -ErrorAction Stop }
	if ($Key) { $oKey = Get-Item -Path $Key -ErrorAction Stop }
	if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

	# Variables
	$ENV:RANDFILE	= $ENV:USERPROFILE + "\.rnd"

	# Check for Encrypted Private Key
	if (!$Encrypt -and (isEncryptedPrivateKey -OpenSslPath $OpenSslPath -Path $oKey.FullName)) {
		Write-Verbose "Detected encrypted private key without encryption declared."
		$Encrypt = $true
	}

	# Check Encryption
	if ($Encrypt) {
		if (!$Passphrase) {
			Write-Verbose "Encryption requested without a supplied passphrase."
			$Passphrase = Read-Host "Private Key Passphrase" -AsSecureString
		}
	}

	# Convert the certificate file (without chain).
	# This process is optional.
	if ($oCertificate) {
		try {
			# Convert the Signed x509 Certificate to PEM
			# This is a direct copy. We run it through OpenSsl anyways to ensure the certificate parses.
			$oResultPem = ConvertTo-Pem `
				-OpenSslPath $OpenSslPath `
				-SourceFormat "x509" `
				-Path $oCertificate `
				-OutPath $oOutPath `
				-ErrorAction Stop

			# Convert the PEM Certificate to DER
			$oResultDer = ConvertTo-Der `
				-OpenSslPath $OpenSslPath `
				-SourceFormat "pem" `
				-Path $oCertificate `
				-OutPath $oOutPath `
				-ErrorAction Continue
		}
		catch { Write-Warning "Failed to convert non-chain certificate." }
	}

	# Convert the PKCS7 (.p7b) Certificate Chain to PEM
	$oResultPemChain = ConvertTo-Pem `
		-OpenSslPath $OpenSslPath `
		-SourceFormat "pkcs7" `
		-Path $oCertificateChain `
		-OutPath $oOutPath `
		-ErrorAction Stop

	# Convert the PKCS7 (.p7b) Certificate Chain to DER
	try {
		$oResultDerChain = ConvertTo-Der `
			-OpenSslPath $OpenSslPath `
			-SourceFormat "pkcs7" `
			-Path $oCertificateChain `
			-OutPath $oOutPath `
			-ErrorAction Continue
	}
	catch { Write-Warning "Failed to convert the certificate to binary format." }

	# Combine the PEM Certificate Chain with the Private Key to PKCS12 (.pfx) with the Private Key
	$oResultPfx = ConvertTo-Pfx `
		-OpenSslPath $OpenSslPath `
		-Encrypt:$Encrypt `
		-Passphrase $Passphrase `
		-Certificate $oResultPemChain `
		-Key $oKey `
		-OutPath $oOutPath `
		-ErrorAction Stop

	# Convert PKCS12 (.pfx) to Java Keystore (.KS) with the Private Key
	if ($JavaPath -and $Passphrase) {
		try {
			$oResultKs = ConvertTo-JavaKeystore `
				-OpenSslPath $OpenSslPath `
				-JavaPath $JavaPath `
				-Passphrase $Passphrase `
				-Path $oResultPfx.Path `
				-OutPath $oOutPath `
				-ErrorAction Continue
		}
		catch { Write-Warning "Failed to convert the certificate to JKS format." }
	}
	else { Write-Warning "Skipped Java Keystore format. Requirements not met." }

	# Create the CA Chain file
	try {
		$oResultCaChain = Export-CaChain `
			-OpenSslPath $OpenSslPath `
			-Encrypt:$Encrypt `
			-Passphrase $Passphrase `
			-SourceFormat "pkcs12" `
			-Path $oResultPfx.Path `
			-OutPath $oOutPath `
			-ErrorAction Continue
	}
	catch { Write-Warning "Failed to export a CA Chain." }

	# Return Data
	return [PSCustomObject] @{
		"PrivateKey"		= [PrivateKey] @{
			"Encrypted"		= $Encrypt
			"Passphrase"	= $Passphrase
			"Path"			= $oKey
		}

		"Certificate"		= [PSCustomObject] @{
			"DER"			= $oResultDer
			"PEM"			= $oResultPem
		}

		"CertificateChain"	= [PSCustomObject] @{
			"DER"			= $oResultDerChain
			"KS"			= $oResultKs.Path
			"PEM"			= $oResultPemChain
			"PFX"			= $oResultPfx.Path
		}

		"CaChain"			= $oResultCaChain
	}
}


Function New-CertificatePackage {
	<#
	.SYNOPSIS
	Creates a new RSA Public/Private KeyPair, submits the certificate for a signature, and converts the resulting certificate to several popular formats.
	.NOTES
	Author:		Matthew Schacherbauer
	Updated:	2019-07-13

	Version:	2.0
	#>

	Param (
		# Resources
		[ValidateScript({Test-Path -Path $_})]
		[string]		$OpenSslPath	= $ENV:OpenSsl + "\bin\openssl.exe",
		[ValidateScript({Test-Path -Path $_})]
		[string]		$JavaPath		= $ENV:Java_Home,

		# Certificate Options
		[string]		$Config,
		[Parameter(Mandatory,Position=0)]
		[string[]]		$Hostname,
		[ValidateSet('1024','2048','3072','4096')]
		[int]			$Bits			= "4096",
		[string]		$CountryName	= "US",
		[string]		$State			= "California",
		[string]		$Locality		= "Sacramento",
		[string]		$PostalCode,
		[string]		$StreetAddress,
		[string]		$Organization	= "WolfSpiritNet",
		[string]		$OrganizationalUnitName	= "Test Lab",
		[string]		$Email,

		# Self-Signed Certificate Length
		[int]			$ValidityDays	= "1826",

		# Active Directory Certificate Services Options
		[string]		$AdcsTemplate	= "WS-WebServer-v2",
		[string]		$AdcsServer		= "WSNOCCA01.lan.wolfspirit.net\WolfSpirit-Net-WSNOCCA01-CA",

		# Encryption Options
		[securestring]	$Passphrase,
		[switch]		$Encrypt,

		# Output Files
		[ValidateScript({Test-Path -Path $_})]
		[string]		$OutPath		= "\\LAN.WOLFSPIRIT.NET\DFS\Documentation\WS PKI\Issued Certificates\" + (Get-Date -Format yyyy)
	)

	Write-Verbose "Call New-CertificatePackage"

	# Create certificate directory
	Write-Verbose "Creating certificate output directory."
	$sOutPath = $OutPath + "\" + $Hostname[0]
	New-Item -ItemType Directory -Path $sOutPath -ErrorAction Inquire | Out-Null

	# Resolve Parameters
	if ($Config) { $oConfig = Get-Item -Path $Config -ErrorAction Stop }
	if ($OutPath) { $oOutPath = Get-Item -Path $sOutPath -ErrorAction Stop }

	# Check Encryption
	if ($Encrypt -and (!$Passphrase)) {
		Write-Verbose "Encryption requested without a supplied passphrase."
		$Passphrase = Read-Host "Private Key Passphrase" -AsSecureString
	}

	# Create Private Key and CSR
	$p = @{
		'OpenSslPath'		= $OpenSslPath
		'Hostname'			= $Hostname
		'Encrypt'			= $Encrypt
		'Passphrase'		= $Passphrase
		'OutPath'			= $oOutPath
	}
	if ($oConfig) { $p.Add('Config',$oConfig) }
	else {
		$p.Add('CountryName',$CountryName)
		$p.Add('State',$State)
		$p.Add('Locality',$Locality)
		$p.Add('PostalCode',$PostalCode)
		$p.Add('StreetAddress',$StreetAddress)
		$p.Add('Organization',$Organization)
		$p.Add('OrganizationalUnitName',$OrganizationalUnitName)
		$p.Add('Email',$Email)
		$p.Add('Bits',$Bits)
	}
	$oResultCsr = New-CertificateSigningRequest @p -ErrorAction Stop

	# Convert the Private Key to PKCS1 Format
	try {
		$p = @{
			'OpenSslPath'		= $OpenSslPath
			'Encrypt'			= $Encrypt
			'Passphrase'		= $Passphrase
			'Path'				= $oResultCsr.PrivateKey.Path
			'OutPath'			= $oOutPath
		}
		$oResultRsa = ConvertTo-Pkcs1 @p -ErrorAction Continue
	}
	catch { Write-Warning "Failed to convert Private Key to RSA format." }

	# Use the Private Key to create a Self Signed Certificate
	try {
		$p = @{
			'OpenSslPath'		= $OpenSslPath
			'ValidityDays'		= $ValidityDays
			'Encrypt'			= $Encrypt
			'Passphrase'		= $Passphrase
			'Config'			= $oResultCsr.CertificateRequest.Config
			'Key'				= $oResultCsr.PrivateKey.Path
			'Request'			= $oResultCsr.CertificateRequest.Path
			'OutPath'			= $oOutPath
		}
		$oResultSelfSigned = New-SelfSignedCertificate @p -ErrorAction Continue
	}
	catch { Write-Warning "Failed to generate a self-signed certificate." }

	# Submit the CSR to an Enterprise CA for Signing
	# Returns a signed x509 certificate, a PKCS7 certificate chain, and a RSP certificate chain
	$p = @{
		'AdcsTemplate'		= $AdcsTemplate
		'AdcsServer'		= $AdcsServer
		'Path'				= $oResultCsr.CertificateRequest.Path
		'OutPath'			= $oOutPath
	}
	$oResultEnterpriseCa = New-EnterpriseCertificateAuthoritySignature @p -ErrorAction Stop


	# Combine the signed certificate issued by Active Directory with the Private Key
	# and convert the resulting certificate to various formats.
	$p = @{
		'OpenSslPath'			= $OpenSslPath
		'Encrypt'				= $Encrypt
		'Passphrase'			= $Passphrase
		'Certificate'			= $oResultEnterpriseCa.Certificate.CRT
		'CertificateChain'		= $oResultEnterpriseCa.CertificateChain.P7B
		'Key'					= $oResultCsr.PrivateKey.Path
		'OutPath'				= $oOutPath
	}
	if ($JavaPath) { $p.Add('JavaPath', $JavaPath) }
	$oResultCertificatePackage = Complete-CertificateSigningRequest @p -ErrorAction Stop

	# Return Generated Certificate Paths												#	EXTENSION		FORMAT		HAS CHAIN		HAS PRIVATE KEY
	return [PSCustomObject] @{															#	=========		======		=========		===============
		"PrivateKey"			= $oResultCsr.PrivateKey								#	.KEY			PKCS8		NO				YES		(Private Key Only)
		"PrivateKeyRsa"			= $oResultRsa											#	.RSA.KEY		PKCS1		NO				YES		(Private Key Only)
		"CertificateConfig"		= $oResultCsr.CertificateRequest.Config					#	.CFG
		"CertificateRequest"	= $oResultCsr.CertificateRequest.Path					#	.CSR
		"SelfCertificate"		= [PSCustomObject] @{
			"CRT"				= $oResultSelfSigned.Certificate						#	.SELF.CRT		x509		NO				NO
			"P7B"				= $oResultSelfSigned.CertificateChain					#	.SELF.P7B		x509		YES				NO
		}
		"Certificate"			= [PSCustomObject] @{
			"CRT"				= $oResultEnterpriseCa.Certificate.CRT					#	.CRT			x509		NO				NO		(Source from ADCS)
			"DER"				= $oResultCertificatePackage.Certificate.DER			#	.DER			DER			NO				NO
			"PEM"				= $oResultCertificatePackage.Certificate.PEM			#	.PEM			PEM			NO				NO
		}
		"CertificateChain"		= [PSCustomObject] @{
			"DER"				= $oResultCertificatePackage.CertificateChain.DER		#	.CHAIN.DER		DER			YES				NO
			"KS"				= $oResultCertificatePackage.CertificateChain.KS		#	.KS				Java KS		YES				YES
			"P7B"				= $oResultEnterpriseCa.CertificateChain.P7B				#	.CHAIN.P7B		PKCS7		YES				NO		(Source from ADCS)
			"PEM"				= $oResultCertificatePackage.CertificateChain.PEM		#	.CHAIN.PEM		PEM			YES				NO
			"PFX"				= $oResultCertificatePackage.CertificateChain.PFX		#	.PFX			PKCS12		YES				YES
			"RSP"				= $oResultEnterpriseCa.CertificateChain.RSP				#	.CHAIN.RSP		RSP			YES				NO		(Source from ADCS)
		}
		"CaChain"				= $oResultCertificatePackage.CaChain					#	.PEM			PEM			YES				NO		(Chain only)
	}
}


# Exported Functions
Export-ModuleMember -Function `
	Protect-PrivateKey, `
	Unprotect-PrivateKey, `
	ConvertTo-Der, `
	ConvertTo-JavaKeystore, `
	ConvertTo-Pem, `
	ConvertTo-Pfx, `
	ConvertTo-Pkcs1, `
	ConvertTo-Pkcs8, `
	Export-CaChain, `
	New-OpenSslCertificateConfiguration, `
	New-CertificateSigningRequest, `
	New-SelfSignedCertificate, `
	New-EnterpriseCertificateAuthoritySignature, `
	Complete-CertificateSigningRequest, `
	New-CertificatePackage


# SIG # Begin signature block
# MIIrtAYJKoZIhvcNAQcCoIIrpTCCK6ECAQExCzAJBgUrDgMCGgUAMGkGCisGAQQB
# gjcCAQSgWzBZMDQGCisGAQQBgjcCAR4wJgIDAQAABBAfzDtgWUsITrck0sYpfvNR
# AgEAAgEAAgEAAgEAAgEAMCEwCQYFKw4DAhoFAAQUTTC6BaQbk3HtiaMrf0yMyMJI
# kHCggiXNMIIEhDCCA2ygAwIBAgIQQhrylAmEGR9SCkvGJCanSzANBgkqhkiG9w0B
# AQUFADBvMQswCQYDVQQGEwJTRTEUMBIGA1UEChMLQWRkVHJ1c3QgQUIxJjAkBgNV
# BAsTHUFkZFRydXN0IEV4dGVybmFsIFRUUCBOZXR3b3JrMSIwIAYDVQQDExlBZGRU
# cnVzdCBFeHRlcm5hbCBDQSBSb290MB4XDTA1MDYwNzA4MDkxMFoXDTIwMDUzMDEw
# NDgzOFowgZUxCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJVVDEXMBUGA1UEBxMOU2Fs
# dCBMYWtlIENpdHkxHjAcBgNVBAoTFVRoZSBVU0VSVFJVU1QgTmV0d29yazEhMB8G
# A1UECxMYaHR0cDovL3d3dy51c2VydHJ1c3QuY29tMR0wGwYDVQQDExRVVE4tVVNF
# UkZpcnN0LU9iamVjdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAM6q
# gT+jo2F4qjEAVZURnicPHxzfOpuCaDDASmEd8S8O+r5596Uj71VRloTN2+O5bj4x
# 2AogZ8f02b+U60cEPgLOKqJdhwQJ9jCdGIqXsqoc/EHSoTbL+z2RuufZcDX65OeQ
# w5ujm9M89RKZd7G3CeBo5hy485RjiGpq/gt2yb70IuRnuasaXnfBhQfdDWy/7gbH
# d2pBnqcP1/vulBe3/IW+pKvEHDHd17bR5PDv3xaPslKT16HUiaEHLr/hARJCHhrh
# 2JU022R5KP+6LhHC5ehbkkj7RwvCbNqtMoNB86XlQXD9ZZBt+vpRxPm9lisZBCzT
# bafc8H9vg2XiaquHhnUCAwEAAaOB9DCB8TAfBgNVHSMEGDAWgBStvZh6NLQm9/rE
# JlTvA73gJMtUGjAdBgNVHQ4EFgQU2u1kdBScFDyr3ZmpvVsoTYs8ydgwDgYDVR0P
# AQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wEQYDVR0gBAowCDAGBgRVHSAAMEQG
# A1UdHwQ9MDswOaA3oDWGM2h0dHA6Ly9jcmwudXNlcnRydXN0LmNvbS9BZGRUcnVz
# dEV4dGVybmFsQ0FSb290LmNybDA1BggrBgEFBQcBAQQpMCcwJQYIKwYBBQUHMAGG
# GWh0dHA6Ly9vY3NwLnVzZXJ0cnVzdC5jb20wDQYJKoZIhvcNAQEFBQADggEBAE1C
# L6bBiusHgJBYRoz4GTlmKjxaLG3P1NmHVY15CxKIe0CP1cf4S41VFmOtt1fcOyu9
# 08FPHgOHS0Sb4+JARSbzJkkraoTxVHrUQtr802q7Zn7Knurpu9wHx8OSToM8gUmf
# ktUyCepJLqERcZo20sVOaLbLDhslFq9s3l122B9ysZMmhhfbGN6vRenf+5ivFBjt
# pF72iZRF8FUESt3/J90GSkD2tLzx5A+ZArv9XQ4uKMG+O18aP5cQhLwWPtijnGMd
# ZstcX9o+8w8KCTUi29vAPwD55g1dZ9H9oB4DK9lA977Mh2ZUgKajuPUZYtXSJrGY
# Ju6ay0SnRVqBlRUa9VEwggTmMIIDzqADAgECAhBiXE2QjNVC+6supXM/8VQZMA0G
# CSqGSIb3DQEBBQUAMIGVMQswCQYDVQQGEwJVUzELMAkGA1UECBMCVVQxFzAVBgNV
# BAcTDlNhbHQgTGFrZSBDaXR5MR4wHAYDVQQKExVUaGUgVVNFUlRSVVNUIE5ldHdv
# cmsxITAfBgNVBAsTGGh0dHA6Ly93d3cudXNlcnRydXN0LmNvbTEdMBsGA1UEAxMU
# VVROLVVTRVJGaXJzdC1PYmplY3QwHhcNMTEwNDI3MDAwMDAwWhcNMjAwNTMwMTA0
# ODM4WjB6MQswCQYDVQQGEwJHQjEbMBkGA1UECBMSR3JlYXRlciBNYW5jaGVzdGVy
# MRAwDgYDVQQHEwdTYWxmb3JkMRowGAYDVQQKExFDT01PRE8gQ0EgTGltaXRlZDEg
# MB4GA1UEAxMXQ09NT0RPIFRpbWUgU3RhbXBpbmcgQ0EwggEiMA0GCSqGSIb3DQEB
# AQUAA4IBDwAwggEKAoIBAQCqgvGEqVvYcbXSXSvt9BMgDPmb6dGPdF5u7uspSNjI
# vizrCmFgzL2SjXzddLsKnmhOqnUkcyeuN/MagqVtuMgJRkx+oYPp4gNgpCEQJ0Ca
# WeFtrz6CryFpWW1jzM6x9haaeYOXOh0Mr8l90U7Yw0ahpZiqYM5V1BIR8zsLbMaI
# upUu76BGRTl8rOnjrehXl1/++8IJjf6OmqU/WUb8xy1dhIfwb1gmw/BC/FXeZb5n
# OGOzEbGhJe2pm75I30x3wKoZC7b9So8seVWx/llaWm1VixxD9rFVcimJTUA/vn9J
# AV08m1wI+8ridRUFk50IYv+6Dduq+LW/EDLKcuoIJs0ZAgMBAAGjggFKMIIBRjAf
# BgNVHSMEGDAWgBTa7WR0FJwUPKvdmam9WyhNizzJ2DAdBgNVHQ4EFgQUZCKGtkqJ
# yQQP0ARYkiuzbj0eJ2wwDgYDVR0PAQH/BAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8C
# AQAwEwYDVR0lBAwwCgYIKwYBBQUHAwgwEQYDVR0gBAowCDAGBgRVHSAAMEIGA1Ud
# HwQ7MDkwN6A1oDOGMWh0dHA6Ly9jcmwudXNlcnRydXN0LmNvbS9VVE4tVVNFUkZp
# cnN0LU9iamVjdC5jcmwwdAYIKwYBBQUHAQEEaDBmMD0GCCsGAQUFBzAChjFodHRw
# Oi8vY3J0LnVzZXJ0cnVzdC5jb20vVVROQWRkVHJ1c3RPYmplY3RfQ0EuY3J0MCUG
# CCsGAQUFBzABhhlodHRwOi8vb2NzcC51c2VydHJ1c3QuY29tMA0GCSqGSIb3DQEB
# BQUAA4IBAQARyT3hBeg7ZazJdDEDt9qDOMaSuv3N+Ntjm30ekKSYyNlYaDS18Ash
# U55ZRv1jhd/+R6pw5D9eCJUoXxTx/SKucOS38bC2Vp+xZ7hog16oYNuYOfbcSV4T
# p5BnS+Nu5+vwQ8fQL33/llqnA9abVKAj06XCoI75T9GyBiH+IV0njKCv2bBS7vzI
# 7bec8ckmONalMu1Il5RePeA9NbSwyVivx1j/YnQWkmRB2sqo64sDvcFOrh+RMrjh
# JDt77RRoCYaWKMk7yWwowiVp9UphreAn+FOndRWwUTGw8UH/PlomHmB+4uNqOZrE
# 6u4/5rITP1UDBE0LkHLU6/u8h5BRsjgZMIIE/jCCA+agAwIBAgIQK3PbdGMRTFpb
# MkryMFdySTANBgkqhkiG9w0BAQUFADB6MQswCQYDVQQGEwJHQjEbMBkGA1UECBMS
# R3JlYXRlciBNYW5jaGVzdGVyMRAwDgYDVQQHEwdTYWxmb3JkMRowGAYDVQQKExFD
# T01PRE8gQ0EgTGltaXRlZDEgMB4GA1UEAxMXQ09NT0RPIFRpbWUgU3RhbXBpbmcg
# Q0EwHhcNMTkwNTAyMDAwMDAwWhcNMjAwNTMwMTA0ODM4WjCBgzELMAkGA1UEBhMC
# R0IxGzAZBgNVBAgMEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBwwHU2FsZm9y
# ZDEYMBYGA1UECgwPU2VjdGlnbyBMaW1pdGVkMSswKQYDVQQDDCJTZWN0aWdvIFNI
# QS0xIFRpbWUgU3RhbXBpbmcgU2lnbmVyMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A
# MIIBCgKCAQEAv1I2gjrcdDcNeNV/FlAZZu26GpnRYziaDGayQNungFC/aS42Lwpn
# P0ChSopjNZvQGcx0qhcZkSu1VSAZ+8AaOm3KOZuC8rqVoRrYNMe4iXtwiHBRZmns
# d/7GlHJ6zyWB7TSCmt8IFTcxtG2uHL8Y1Q3P/rXhxPuxR3Hp+u5jkezx7M5ZBBF8
# rgtgU+oq874vAg/QTF0xEy8eaQ+Fm0WWwo0Si2euH69pqwaWgQDfkXyVHOaeGWTf
# dshgRC9J449/YGpFORNEIaW6+5H6QUDtTQK0S3/f4uA9uKrzGthBg49/M+1BBuJ9
# nj9ThI0o2t12xr33jh44zcDLYCQD3npMqwIDAQABo4IBdDCCAXAwHwYDVR0jBBgw
# FoAUZCKGtkqJyQQP0ARYkiuzbj0eJ2wwHQYDVR0OBBYEFK7u2WC6XvUsARL9jo2y
# VXI1Rm/xMA4GA1UdDwEB/wQEAwIGwDAMBgNVHRMBAf8EAjAAMBYGA1UdJQEB/wQM
# MAoGCCsGAQUFBwMIMEAGA1UdIAQ5MDcwNQYMKwYBBAGyMQECAQMIMCUwIwYIKwYB
# BQUHAgEWF2h0dHBzOi8vc2VjdGlnby5jb20vQ1BTMEIGA1UdHwQ7MDkwN6A1oDOG
# MWh0dHA6Ly9jcmwuc2VjdGlnby5jb20vQ09NT0RPVGltZVN0YW1waW5nQ0FfMi5j
# cmwwcgYIKwYBBQUHAQEEZjBkMD0GCCsGAQUFBzAChjFodHRwOi8vY3J0LnNlY3Rp
# Z28uY29tL0NPTU9ET1RpbWVTdGFtcGluZ0NBXzIuY3J0MCMGCCsGAQUFBzABhhdo
# dHRwOi8vb2NzcC5zZWN0aWdvLmNvbTANBgkqhkiG9w0BAQUFAAOCAQEAen+pStKw
# pBwdDZ0tXMauWt2PRR3wnlyQ9l6scP7T2c3kGaQKQ3VgaoOkw5mEIDG61v5MzxP4
# EPdUCX7q3NIuedcHTFS3tcmdsvDyHiQU0JzHyGeqC2K3tPEG5OfkIUsZMpk0uRlh
# dwozkGdswIhKkvWhQwHzrqJvyZW9ljj3g/etfCgf8zjfjiHIcWhTLcuuquIwF4Mi
# KRi14YyJ6274fji7kE+5Xwc0EmuX1eY7kb4AFyFu4m38UnnvgSW6zxPQ+90rzYG2
# V4lO8N3zC0o0yoX/CLmWX+sRE+DhxQOtVxzhXZIGvhvIPD+lIJ9p0GnBxcLJPufF
# cvfqG5bilK+GLjCCBdAwggO4oAMCAQICEEFxbGuXPYiATs5STyUAMskwDQYJKoZI
# hvcNAQELBQAwZzETMBEGCgmSJomT8ixkARkWA25ldDEaMBgGCgmSJomT8ixkARkW
# CndvbGZzcGlyaXQxEzARBgoJkiaJk/IsZAEZFgNsYW4xHzAdBgNVBAMTFldvbGZT
# cGlyaXQtTmV0LVJvb3QtQ0EwHhcNMTYwMjI1MTY0OTU2WhcNMzYwMjI1MTY1OTU1
# WjBnMRMwEQYKCZImiZPyLGQBGRYDbmV0MRowGAYKCZImiZPyLGQBGRYKd29sZnNw
# aXJpdDETMBEGCgmSJomT8ixkARkWA2xhbjEfMB0GA1UEAxMWV29sZlNwaXJpdC1O
# ZXQtUm9vdC1DQTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAKRv9HV2
# D+8b5mWFNeynifCWBSj4iuvxiHESsULIp+G2aOtkkaf1rIy+A6JfkvdnW363weeL
# d0ncPRJEiE+yRhg5SDV0JogNb+EKYUuznd2R0Ku9bxyaTnlEf/M+kMdZKKFGedZ2
# Om3LgO1FfLQoVkSnSgzY+aMRoh7e3+tR4fMRQvo3w7D9HMUopXvGaDACN5ucAOH5
# p8yoUkEgZmhzxOkKTouYhdqI8BlZiz7LmTZycuM/zL51+Md3JvAVxjDp5T2ViLRh
# V/3cLoXNG/h4BT6MW3ca5ACFtt0B2GWxDsQByzHtw3fb8J+VDsgbM+de1pXsSZL6
# YEm0jH6WWpvb2whThE2EKc7WLOrBcH2KAXbUOuMC/7Pg+3IXw2NN421xLlIbgYSh
# jYRxnRifjGApOPYlAMUWRT/k7a9v1sIXdYmsKW6/5sslNKGEJ0I9HZ+IJgEXxJu8
# 7xC3QYZsftOl7kPeff0iKw0vMDZ/4bq/0GFERDhbyB4PYdiL2vLgywGraoCHlZDS
# kQeArp5ZcspqWDdSqU59SCRZJ6ZkqS6tY5p2abT33TeB+RSfIqgIclvmEf5JCt70
# tP0tZDNu1ZvPc8AelN0pC7vPUcDCmiFwL0n2wOEh13Yb/QLVsmrNRSyUjUHXgQuS
# B3bFE84iKV3QkNs5YUkQ+3qgJbgCVgHqquBbAgMBAAGjeDB2MAsGA1UdDwQEAwIB
# hjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBSYNr4hokUsroVXWcTxntn1wArM
# xDASBgkrBgEEAYI3FQEEBQIDAwADMCMGCSsGAQQBgjcVAgQWBBRXGDnMVbZ9/N/o
# eV5aDKxnVEODhDANBgkqhkiG9w0BAQsFAAOCAgEAT2ie0agiFJrZXjXzYFuADrQT
# 5Xg5ZKmdzzPrIPwWEQA/nb0Bq8ZaNM2qnPYIPHu6spHf3hKrwZLpYqEukPe/TM0b
# E/GzrhDNVgrodLWylz/OHfjPQn8UjdP4Ma/UQ+YD/gZo6k/Exp41LXxSMMfb+9fC
# iWnm28IpbF7FWnfEhyD+/LiREksE9BFhq5mTiiw/UfkjKQLFSkIRcbNkUoEpHnFV
# ec+t/pgBesMf6Tt8X9fzgsGuAPruczo7zoSbtR4KtawNSkGiE5GHKt7Dmgrig7vY
# jxMewNxfG4/yBxyMWLB8Y9xnKU3aXxWQ1PjXVW3H34YtJz4gqtju2Zx5Lo7dBg9N
# NFmTunI+r0O2h0Ub1/8MecKKx1xchLWtXGFftSB6zNhOxrB6lwhwWpOaKgZ/vqot
# 6C9kAQ0kJRjA/JZnxixGQCxlrRnxJsFYlLu8Sxcc86VQW/zNu7ta78foe/dYfSmu
# XHDPIUYws8ZBkxFoONbSoRhaO0bkUvS6PUqRUURj5KUHw9j0C/cTFGkJNr8cUVsE
# /kV5njERkr/zslwCi3s23dePZVo0m4JopK4XTN+eiqdBb4KG1PH+p4JQiezF8HAi
# zrWLEQf7DmJm5Jk7p2J7dgK85vLi0gX33sZoo/5vkhieU9pcSmHs7Jl5Ozq+ZbVo
# lyjB8iOpp3jSixNAW7wwgghjMIIGS6ADAgECAhN7AAAAH8+fJanQVeArAAMAAAAf
# MA0GCSqGSIb3DQEBCwUAMGcxEzARBgoJkiaJk/IsZAEZFgNuZXQxGjAYBgoJkiaJ
# k/IsZAEZFgp3b2xmc3Bpcml0MRMwEQYKCZImiZPyLGQBGRYDbGFuMR8wHQYDVQQD
# ExZXb2xmU3Bpcml0LU5ldC1Sb290LUNBMB4XDTE4MDIwNDA0MzIwNFoXDTIzMDIw
# MzA0MzIwNFowbDETMBEGCgmSJomT8ixkARkWA25ldDEaMBgGCgmSJomT8ixkARkW
# CndvbGZzcGlyaXQxEzARBgoJkiaJk/IsZAEZFgNsYW4xJDAiBgNVBAMTG1dvbGZT
# cGlyaXQtTmV0LVdTTk9DQ0EwMS1DQTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCC
# AgoCggIBAOwJqdHih24K3ed7BBqb3i4eowqkG/hU19xnCchF12CSvhDUQhDn5MpO
# hN4EOxnQLq0OY8kOKSnG23TzsdIR+TNHFlFuoHJsHeMRfE1y5crcnz7hHlvuqZPh
# mlcL56h0p9ZeL/nNf0L7nIpyZohN4PpeFIMvaH+gbNEUdRJT061Olia10w3ctL/u
# igH5KE3WuhK/SEGL/Grrj+qElTSuEXtSQFZyzrCBdNuVEuh83r12EPPzAVbyB/ki
# Kzwnf1cr/ho34bQb/HEd8AK1M4EZXtptdmjNiHA7KRRd4IRI/jLQDSBiuYogGX6h
# 6m2jgFR2ArCfkmI4RIE0rG3FOYrlDqowPEB5Z4Q3I4CxdzxaTctQkqYc7NCXVIFw
# deLnaWB3tn6bi9mBr405ihc0O58kQoNSx/TNC8+gRPJ2MDJiGPWlqh7g8qzPDRzs
# ELE4Ic9h/ro79WgIeC6kISqZdXXKicYeMH19z127o/duZQH4Rbf514ZsYx/HLjls
# 9l24408G4sa3IxNPm0s/wl4AJdvkwHW7zqUm9m70ffsGnGOWkH75YszGFZZF8ZDF
# AOdMfB0wiI0YNocqogpwkicB0meAr/Rk9psi1aI9pzIBkWii2R47L9rke2Cmr6QD
# U6MVzQIrPqF4IEg7gh99ekh6w8t9XoDOPO8bEOAOWwr5JFezHKdzAgMBAAGjggMB
# MIIC/TAQBgkrBgEEAYI3FQEEAwIBADAdBgNVHQ4EFgQUmEIEpsUgCm8BbjNwfNCx
# 8BynJKkwGQYJKwYBBAGCNxQCBAweCgBTAHUAYgBDAEEwDgYDVR0PAQH/BAQDAgGG
# MA8GA1UdEwEB/wQFMAMBAf8wHwYDVR0jBBgwFoAUmDa+IaJFLK6FV1nE8Z7Z9cAK
# zMQwggEpBgNVHR8EggEgMIIBHDCCARigggEUoIIBEIaByWxkYXA6Ly8vQ049V29s
# ZlNwaXJpdC1OZXQtUm9vdC1DQSgzKSxDTj1XUy1SQ0EsQ049Q0RQLENOPVB1Ymxp
# YyUyMEtleSUyMFNlcnZpY2VzLENOPVNlcnZpY2VzLENOPUNvbmZpZ3VyYXRpb24s
# REM9bGFuLERDPXdvbGZzcGlyaXQsREM9bmV0P2NlcnRpZmljYXRlUmV2b2NhdGlv
# bkxpc3Q/YmFzZT9vYmplY3RDbGFzcz1jUkxEaXN0cmlidXRpb25Qb2ludIZCaHR0
# cDovL2NybC53b2xmc3Bpcml0Lm5ldC9jcmwvV1MtUkNBL1dvbGZTcGlyaXQtTmV0
# LVJvb3QtQ0EoMykuY3JsMIIBPgYIKwYBBQUHAQEEggEwMIIBLDCBvwYIKwYBBQUH
# MAKGgbJsZGFwOi8vL0NOPVdvbGZTcGlyaXQtTmV0LVJvb3QtQ0EsQ049QUlBLENO
# PVB1YmxpYyUyMEtleSUyMFNlcnZpY2VzLENOPVNlcnZpY2VzLENOPUNvbmZpZ3Vy
# YXRpb24sREM9bGFuLERDPXdvbGZzcGlyaXQsREM9bmV0P2NBQ2VydGlmaWNhdGU/
# YmFzZT9vYmplY3RDbGFzcz1jZXJ0aWZpY2F0aW9uQXV0aG9yaXR5MGgGCCsGAQUF
# BzAChlxodHRwOi8vY3JsLndvbGZzcGlyaXQubmV0L2NybC9XUy1SQ0EvV1MtUkNB
# Lmxhbi53b2xmc3Bpcml0Lm5ldF9Xb2xmU3Bpcml0LU5ldC1Sb290LUNBKDMpLmNy
# dDANBgkqhkiG9w0BAQsFAAOCAgEAD5e//JQmlKNdb9L5owNtDhYDjZm6Lgh9LAPP
# jzcKWdTGvxdEzrPkmJjudUm3qvPKgxMo1UCSGRwcyxlDoyu/d3lelRRxcAKfJknY
# KoQ6tj4gYqdLTVEytoRmrIyPFTrfLuLv+s+mwXKNIHpkzWjnQw8I+q2K996T1hby
# Ld41TLSFmRumEt5wj9Kxb+2+lcX7a5+zJ7Dq1WQ0kaGGb4s/ooLer7DqzYYEHq9L
# xJUPrPKbzSUEhc0g11gcEAOheIwMNybXefYlpW0j6/CSK9wlUPO+gPL9rBCKTYLA
# 28wuQc9kBHBVvO9XZxGnJZcWfa0hBlcTL15dULAKGJR5SdUqwiJCDSbrqyoFQBs5
# +6/sY3SYyzCqgZuU/UoLsrxc1lq4k2FaMPpvaQmzUYkiGryqGlB4FzHnclTE1/WB
# tvUAQb7xyK3HKurRHKGZL3oqV+drh5sSJp9+/Y7yTR8md0MNTEyfg+Jykf9YGDLn
# NjtXnKIrlAVf94+Lu9xChxcfRaz9Oko1lFEqK8BYf+W0Iadsf+Q2JQEkl7K2s4HB
# trjYxHhgL2hbTtid7U/EICE3+UFPqootxxJ7LYS154ZJlEJtd1rRnpLFD1dpWAcJ
# V41ENrvlLguAngYM9EkA90rBuyZtMKq+XpMn0PdtBSceWI6QhTcG0XuLYTU8TNud
# 7Vsj8e8wggkaMIIHAqADAgECAhNjAAABGBgj5UpXeSWiAAAAAAEYMA0GCSqGSIb3
# DQEBCwUAMGwxEzARBgoJkiaJk/IsZAEZFgNuZXQxGjAYBgoJkiaJk/IsZAEZFgp3
# b2xmc3Bpcml0MRMwEQYKCZImiZPyLGQBGRYDbGFuMSQwIgYDVQQDExtXb2xmU3Bp
# cml0LU5ldC1XU05PQ0NBMDEtQ0EwHhcNMTkwMTIwMjI0NjA4WhcNMjAwMTIwMjI0
# NjA4WjCBnDETMBEGCgmSJomT8ixkARkWA25ldDEaMBgGCgmSJomT8ixkARkWCndv
# bGZzcGlyaXQxEzARBgoJkiaJk/IsZAEZFgNsYW4xEzARBgNVBAsTCldvbGZTcGly
# aXQxDjAMBgNVBAsTBVVzZXJzMQ8wDQYDVQQLEwZIdW1hbnMxHjAcBgNVBAMTFU1h
# dHRoZXcgU2NoYWNoZXJiYXVlcjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoC
# ggIBAMwizniCvTUGl1NbtXJQrmFl4WnxwVfNQ7P2Hve/tH7Iyyu5HMgOExWyTtWQ
# Lmw5P7bOVLGtS931enlreD7GirluzcgWGng3m+28vwFs+umsQ1izYrLK21t6IPWX
# 8HqQP/OP/nFxdk6f9TD6xL08xFEEBLQYLQO/bie46X4QsleSLU9XQe+Dt3pBkdy2
# NizJnm1ihF9XVdyrId68CzvdKkM8Ra3nSj2jWfS9tSBgnBeat/gNr0H/VQsP4bLA
# 9hYiqcjn4omSRKMAkJmL9ghDVVXnq6qUt+z+0aQmU0kE/GoVkpviamLXJbcgBSh0
# JMN8e3EF7y/Mo4U2uznLYC/6qfmpRUuge2SfKVAHj0eRWgsTYtrYuAr5bGlp0/ev
# ed8UxA7ZFCszxU/HSH5Jb0Lj7tLlkBPxTYfMRO+fKqmTmT8CXefi5H56+c6kVoMr
# iXJOMedX6516kVS+EwnBGM3kps46UsJQcrHZ9BQb7G3btcYwEdCYdYikE0mgm4P4
# sNLF2PyALU7xAtnqVNEWgOJ5qGI+m6IoT6PI0woN8fDXH5xfJ03b3fsDXv4EoY67
# DVN2B7GgZFuHNb/3usBlF5xA2JAbxojiubiH/7jle+NrVMu5ED69HzoPv3VivQVk
# J95ktIlhtgR4FBue5JxxKEBfTK3Nhtxj2RZcCjJjLMu66AVhAgMBAAGjggOCMIID
# fjA9BgkrBgEEAYI3FQcEMDAuBiYrBgEEAYI3FQiC34xBgsKsbIKNlyGD9/UKhqiK
# dwyDmd8pgtimJgIBZAIBHDATBgNVHSUEDDAKBggrBgEFBQcDAzAOBgNVHQ8BAf8E
# BAMCB4AwGwYJKwYBBAGCNxUKBA4wDDAKBggrBgEFBQcDAzA1BgNVHREELjAsoCoG
# CisGAQQBgjcUAgOgHAwabWF0dGhld0BsYW4ud29sZnNwaXJpdC5uZXQwHQYDVR0O
# BBYEFHKjSfF8pKht2eJdZR3EG2mS+X8EMB8GA1UdIwQYMBaAFJhCBKbFIApvAW4z
# cHzQsfAcpySpMIIBMwYDVR0fBIIBKjCCASYwggEioIIBHqCCARqGgc5sZGFwOi8v
# L0NOPVdvbGZTcGlyaXQtTmV0LVdTTk9DQ0EwMS1DQSxDTj1XU05PQ0NBMDEsQ049
# Q0RQLENOPVB1YmxpYyUyMEtleSUyMFNlcnZpY2VzLENOPVNlcnZpY2VzLENOPUNv
# bmZpZ3VyYXRpb24sREM9bGFuLERDPXdvbGZzcGlyaXQsREM9bmV0P2NlcnRpZmlj
# YXRlUmV2b2NhdGlvbkxpc3Q/YmFzZT9vYmplY3RDbGFzcz1jUkxEaXN0cmlidXRp
# b25Qb2ludIZHaHR0cDovL2NybC53b2xmc3Bpcml0Lm5ldC9jcmwvV1NOT0NDQTAx
# L1dvbGZTcGlyaXQtTmV0LVdTTk9DQ0EwMS1DQS5jcmwwggFLBggrBgEFBQcBAQSC
# AT0wggE5MIHEBggrBgEFBQcwAoaBt2xkYXA6Ly8vQ049V29sZlNwaXJpdC1OZXQt
# V1NOT0NDQTAxLUNBLENOPUFJQSxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxD
# Tj1TZXJ2aWNlcyxDTj1Db25maWd1cmF0aW9uLERDPWxhbixEQz13b2xmc3Bpcml0
# LERDPW5ldD9jQUNlcnRpZmljYXRlP2Jhc2U/b2JqZWN0Q2xhc3M9Y2VydGlmaWNh
# dGlvbkF1dGhvcml0eTBwBggrBgEFBQcwAoZkaHR0cDovL2NybC53b2xmc3Bpcml0
# Lm5ldC9jcmwvV1NOT0NDQTAxL1dTTk9DQ0EwMS5sYW4ud29sZnNwaXJpdC5uZXRf
# V29sZlNwaXJpdC1OZXQtV1NOT0NDQTAxLUNBLmNydDANBgkqhkiG9w0BAQsFAAOC
# AgEA1OcF/o5i418n+qY7yBQS89iO2SgLQHLp32jGHg+rDs05wOPe80mWellv8p/U
# B6QcccUJ44oHYj9fvOrDQGEqeqfjP2E4KQDR0mRoeMpDDU9M7uO5dA1tfp/1P/RT
# GCBFvtkzwkNs27YnpvyHVYgVi1y5rL0HMWZCdd9mLNQlK7jJkAnsftOo1kEIJsyt
# IQuNPcceWA1LOyI3v15CA/x5uTk5twYNVa1eu8jnbfQpDKL25NG6wN5DFqyweQz1
# I7MFWu5fCxVjWcP0YnoSb8ytF5jCYu3UmAsxxuu2+GvdQyU2CrBKSuUUlWRwuUqJ
# ezyiy/BjAq7X+duBirbGAk8/wP+p3jqXsaKdiHw+eL+DFU7Mj2nfBy1prqnzdifl
# o2d1oQkj8J//A5Q58lzJ02UZqJgXNXvkhcskkScCjMZzws+tZFD3uJh9i2sebRwX
# hMEM/yQ5xXuUl4y7ZaGHY3d8RoxavVcbLA6hl5uMNjp4sK8W/q9HzLBYSMcKfQRi
# fS0RyYm3B8ezkNGkvmiMse9GO9/m3ruK0wjIXwJ0XrXeJFX3OCMbdZ4hHRWrvW4S
# Gsv3wnaNQyah+XY/bA60APcSM1/H0utcg32DSaLYTEPZRIVOnTzdpDg6+wrRk4Ap
# p7ALt6qZqkUxmOqL3zhkgrRBZ9V+TpfPcDwm0bvo9cYwo8wxggVRMIIFTQIBATCB
# gzBsMRMwEQYKCZImiZPyLGQBGRYDbmV0MRowGAYKCZImiZPyLGQBGRYKd29sZnNw
# aXJpdDETMBEGCgmSJomT8ixkARkWA2xhbjEkMCIGA1UEAxMbV29sZlNwaXJpdC1O
# ZXQtV1NOT0NDQTAxLUNBAhNjAAABGBgj5UpXeSWiAAAAAAEYMAkGBSsOAwIaBQCg
# eDAYBgorBgEEAYI3AgEMMQowCKACgAChAoAAMBkGCSqGSIb3DQEJAzEMBgorBgEE
# AYI3AgEEMBwGCisGAQQBgjcCAQsxDjAMBgorBgEEAYI3AgEVMCMGCSqGSIb3DQEJ
# BDEWBBTGPZFNGi1Kd6ddofUpVTSxwlm33zANBgkqhkiG9w0BAQEFAASCAgAl44tr
# 4f6RByYqVXp4GKlTLtXgrrHoPv2oZSXyg/nMHhLIUzjwCXth9MNGEhr7bCMc4256
# sjv+jMvk1RPerQrBtO6EuTy1meXr+lHvL4NwiNsIhFYH61WXhA05MLDQVKA1H2En
# awZv01FKDB9i/6cVShtYIeJUOXydi6Gcj74NrzRnlbZZFnAj22IH3Lo/+Jsif5G6
# tnMgcpmOvST0xYNN7ub0LdBFrc8CPvepTRsNEwYGAdorMxi9KXcNa2u1j9xhLvf2
# Pe5Qvob9UuoOexSVK7gW6oWKZFkqV20HW740TrfQJdudqrh80TCOh/Pi9FexOS8K
# kuQvAd8P4SXb2B1Y5+cFWB6y5H1d1kghzGZaVYaLJlIgjZe5qT9TpCjgmTCo2gVa
# HlfbC3DKUv6EjVjNHBR1YiPSO3V3CD0YhxFqN9/fj2IR6czuttpV5Frl9t/mMi5D
# 0Eo0qHwUUdSnI5ejgtVlrTrD0Aq0iueo1HnQsPeOUs0kDT2K4hZMg95/IA8AxAM9
# xSd5NaWapgntXMf/7AfqbRcd6q8+ntSn2FDngNgJwGYP0YBxS19vCvqQ8Ct3EW0m
# DRNvsRaxGqJgc0+c/7TdxjclfbkShxD6IYRFtVcMgZroWjGcC5ZQYr52wGBH9Kjw
# +JHTRGkd+F2bDoBTDli2CsLNShVYF1rJQD6i6aGCAigwggIkBgkqhkiG9w0BCQYx
# ggIVMIICEQIBATCBjjB6MQswCQYDVQQGEwJHQjEbMBkGA1UECBMSR3JlYXRlciBN
# YW5jaGVzdGVyMRAwDgYDVQQHEwdTYWxmb3JkMRowGAYDVQQKExFDT01PRE8gQ0Eg
# TGltaXRlZDEgMB4GA1UEAxMXQ09NT0RPIFRpbWUgU3RhbXBpbmcgQ0ECECtz23Rj
# EUxaWzJK8jBXckkwCQYFKw4DAhoFAKBdMBgGCSqGSIb3DQEJAzELBgkqhkiG9w0B
# BwEwHAYJKoZIhvcNAQkFMQ8XDTE5MDcxNDAwMjMxNVowIwYJKoZIhvcNAQkEMRYE
# FPJNgYcLVCNTi3EbN8xsgdsW5zSgMA0GCSqGSIb3DQEBAQUABIIBAJXD7S4jWwLC
# Z26ohzGoLmcWx6tVNxyr0kU807LXBrHiIkkchZctwSCiT70InT46tkEzkapxJGRQ
# kDxwQdQKJZa6UJmC/TMk8XLJeKCdo+XS9cghxWJgFH4Ek56+3o6NRnEyl0lteTFC
# LbBoLtCOoXCqiBxXNzbM02qwhj5RfYgnGxlm4vxG1y21ebzxdgOHnl8TopVYLTWV
# 7vpLXTcV9LyceGtLaNKKSOLKAQTh9ckK8nZzeJdn6bbOf0pbNC7ghngKgCuK8HYz
# RLPOZ7OIHr6RJZM6x1aLh4H9DrgfEp5QkOM4ODnWT4nNJ16abQxm15+rwtP6IrOX
# +OUPUXTAo5U=
# SIG # End signature block
