<#

CERTIFICATE GENERATION MODULE

Matthew Schacherbauer
2022-06-10

https://github.com/matthewschacherbauer
https://www.matthewschacherbauer.com

===============

EXTERNAL RESOURCES REQUIRED

OpenSSL is required for this module to run.
By default, the OpenSSL directory is expected to be defined in the environment
variable $ENV:OpenSsl, or the path can be overridden with -OpenSslPath.

Java is required to convert a certificate into the Java Keystore format.
By default, the Java install is expected to be defined in the environment
variable $ENV:Java_Home, or the path can be overridden with -JavaPath.
If Java is not present, the JKS conversion will be skipped.
A passphrase is required to export in JKS format.

===============

ENTERPRISE CA USAGE SUMMARY

-> New-CertificatePackage <-
Creates a CSR using OpenSSL.
Submits the CSR to a Microsoft Enterprise CA for signing.
Converts the resulting signed certificate to several popular formats.

EXTERNAL CA USAGE SUMMARY

-> New-CertificateSigningRequest <-
Creates a CSR using OpenSSL for manual submission to a public Certificate Authority.

-> Complete-CertificateSigningRequest <-
Combines a certificate signed by a public Certificate Authority with the private key
generated by New-CertificateSigningRequest.
Converts the resulting signed certificate to several popular formats.

CERTIFICATE FORMAT CONVERSION SUMMARY

Additional commandlets are provided to convert pre-existing certificates to various
formats. These commandlets are used by the above general functions.

===============
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
===============

#>

#Requires -Version 3.0


Class PrivateKey {
    [bool]                  $Encrypted
    [securestring]          $Passphrase
    [system.io.fileinfo]    $Path
}


Function isEncryptedPrivateKey {
    <#
    .SYNOPSIS
    Checks if the Private Key is encrypted.
    .PARAMETER OpenSslPath
    The path to the OpenSSL binary, openssl.exe.
    .PARAMETER Path
    The path to the Private Key file.
    .OUTPUTS
    $True if the Private Key is detected to be encrypted.
    $False otherwise.
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2019-06-30
        
    Version:    1.3
    .LINK
    https://github.com/matthewschacherbauer
    https://www.matthewschacherbauer.com
    #>

    [CmdletBinding()]
    Param (
        [ValidateScript({Test-Path -Path $_})]
        [string] $OpenSslPath = $ENV:OpenSsl + "\bin\openssl.exe",

        # Source Data
        [Parameter(Mandatory,ParameterSetName="Path")]
        [ValidateScript({Test-Path -Path $_})]
        [string] $Path
    )

    # For PFX files, use OpenSSL to parse the private key.
    if ((Get-Item -Path $Path -ErrorAction SilentlyContinue).Extension -eq ".pfx") {
        $sResult = CMD.EXE /C "`"$($OpenSslPath)`" pkcs12 -in `"$($Path)`" -cacerts -nokeys -noout -passin pass:" '2>&1'
        if ($sResult -like "Mac verify error*") {
            return $true
        }
    }

    # For all other types, attempt to read the key text for ENCRYPTED in the string.
    else {
        if (Test-Path -Path $Path -ErrorAction SilentlyContinue) {
            $sKey = Get-Content -Path $Path
        }
        else {
            Throw "No Private Key data to parse."
        }

        if ($sKey -like "*ENCRYPTED*") {
            return $true
        }
    }

    return $false
}


Function ReadCertificateFromFile {
    <#
    HELPER FUNCTION

    Read a certificate file.
    #>

    Param (
        [ValidateScript({Test-Path -Path $_})]
        $Path
    )

    $oCertificate = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Certificate2
    $oCertificate.Import($Path)

    return $oCertificate
}


Function ReadCertificateSigningRequestFromFile {
    <#
    HELPER FUNCTION

    Read a certificate signing request file.
    #>

    Param (
        [ValidateScript({Test-Path -Path $_})]
        $Path
    )

    $oCsr = New-Object -ComObject X509Enrollment.CX509CertificateRequestPkcs10
    $oCsr.InitializeDecode( (Get-Content -Path $Path), 6)

    return $oCsr
}


Function DecodeCsrSan {
    <#
    Use .NET to decode the CSR.
    For Subject Alternative Names, this appears to only recognize DNS entries.
    #>

    [CmdletBinding()]
    Param (
        $Object
    )

    $returnData = [PSCustomObject] @{
        'Hostname'  = @()
        'IP'        = @()
        'Email'     = @()
        'RawData'   = ""
    }

    foreach ($thisExtension in $Object.X509Extensions) {
        if ($thisExtension.ObjectId.Value -eq "2.5.29.17") {
            # This is a SAN extension
            $CsrSanObject = New-Object -ComObject X509Enrollment.CX509ExtensionAlternativeNames
            $CsrSanObject.InitializeDecode(4, $thisExtension.RawData(4))
            $returnData.RawData = $CsrSanObject.AlternativeNames
        }
    }

    foreach ($thisHostname in $returnData.RawData) {
        if ($thisHostname.Type -eq "3") {
            Write-Verbose "Adding SAN Hostname Value: $($thisHostname.strValue)"
            $returnData.Hostname += $thisHostname.strValue
        }
    }

    # TODO: IP Retrieval

    # TODO: Email (RFC822 Name) Retrieval

    return $returnData
}


Function DecodeCsrWithOpenssl {
    # Use OpenSSL to decode the CSR.

    [CmdletBinding()]
    Param (
        [ValidateScript({Test-Path -Path $_})]
        $OpenSslPath = $ENV:OpenSsl + "\bin\openssl.exe",
        [ValidateScript({Test-Path -Path $_})]
        $Path
    )

    if (!$ENV:RANDFILE) { $ENV:RANDFILE = $ENV:USERPROFILE + "\.rnd" }
    if (!$ENV:OPENSSL_CONF) { $ENV:OPENSSL_CONF = "$($OpenSslPath.Replace("openssl.exe","openssl.cnf"))" }

    $returnData = [PSCustomObject] @{
        'Subject' = [PSCustomObject] @{
            'CN' = ""   # CommonName
            'OU' = ""   # OrganizationalUnit
            'O' = ""    # Organization
            'L' = ""    # Locality
            'ST' = ""   # State
            'C' = ""    # Country
            'emailAddress' = ""
        }
        'SAN' = [PSCustomObject] @{
            'DNS' = @()
            'IP' = @()
            'Email' = @()
        }
    }

    # Note: Redirect STDERR from openssl because it writes non-errors to it.
    $sCmd = "`"$($OpenSslPath)`" req -text -noout -verify -in `"$($Path)`" 2> nul"

    # Execute Command
    Write-Verbose "Executing Command: $($sCmd)"
    $sResult = CMD.EXE /C $sCmd '2>&1'

    # TODO: Capture and parse OpenSSL response.
    if ($?) { Write-Verbose ($sResult | Out-String) }
    else { Throw ($sResult | Out-String) }
 
    # Parse for attributes
    $sSan = $sResult | Where-Object { ($_ -like "*DNS*") -or ($_ -like "*IP Address*") -or ($_ -like "*RFC822*") -or ($_ -like "*email*") }
    $sSubj = $sResult | Where-Object { $_ -like "*Subject:*" }
 
    if ($sSan) {
        $sSan = $sSan.Trim().Split(":").Split(",").Trim()

        for ($i = 0; $i -lt $sSan.count; $i++) {
            switch ( $sSan[$i] ) {
                'DNS'           { $returnData.SAN.DNS += $sSan[$i+1] }
                'IP Address'    { $returnData.SAN.IP += $sSan[$i+1] }
                'RFC822 Name'   { $returnData.SAN.Email += $sSan[$i+1] }
                'email'         { $returnData.SAN.Email += $sSan[$i+1] }
            }
        }
    }
    
    if ($sSubj) {
        $sSubj = $sSubj.Trim().Split(":").Split("=").Split(",").Trim()

        for ($i = 0; $i -lt $sSubj.count; $i++) {
            switch ( $sSubj[$i] ) {
                'CN'        { $returnData.Subject.CN += $sSubj[$i+1] }  # CommonName
                'OU'        { $returnData.Subject.OU += $sSubj[$i+1] }  # OrganizationalUnit
                'O'         { $returnData.Subject.O += $sSubj[$i+1] }   # Organization
                'L'         { $returnData.Subject.L += $sSubj[$i+1] }   # Locality
                'ST'        { $returnData.Subject.ST += $sSubj[$i+1] }  # State
                'C'         { $returnData.Subject.C += $sSubj[$i+1] }   # Country
                'emailAddress' { $returnData.Subject.emailAddress += $sSubj[$i+1] }
            }
        }
    }
 
    return $returnData
}


Function GetCertificateSigningRequestSan {
    <#
    HELPER FUNCTION

    Retrieves the Subject Alternative Name (SAN) field from a Certificate Signing Request object.
    If reading from file, use ReadCertificateSigningRequestFromFile first.
    #>

    Param (
        $Object
    )

    foreach ($thisExtension in $Object.X509Extensions) {
        if ($thisExtension.ObjectId.Value -eq "2.5.29.17") {
            # Is a SAN extension
            $oCsrSan = New-Object -ComObject X509Enrollment.CX509ExtensionAlternativeNames
            $oCsrSan.InitializeDecode(4, $thisExtension.RawData(4))
            return $oCsrSan.AlternativeNames
        }
    }
}


Function Protect-PrivateKey {
    <#
    .SYNOPSIS
    Adds encryption to a Private Key
    .PARAMETER OpenSslPath
    The path to the OpenSSL binary, openssl.exe.
    .PARAMETER Passphrase
    A passphrase to use for encryption of the Private Key.
    .PARAMETER Rsa
    Specifies that RSA (PKCS1) encryption format should be used.
    .PARAMETER Path
    The path to the unencrypted, source Private Key.
    .PARAMETER OutKey
    The path for writing the encrypted Private Key.
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2019-06-30
    .LINK
    https://github.com/matthewschacherbauer
    https://www.matthewschacherbauer.com
    #>

    [CmdletBinding()]
    Param (
        [ValidateScript({Test-Path -Path $_})]
        [string] $OpenSslPath = $ENV:OpenSsl + "\bin\openssl.exe",

        # Encryption Option
        [Parameter(Mandatory)]
        [Securestring] $Passphrase,

        # Format
        [switch] $Rsa,

        # Source Files
        [Parameter(Mandatory)]
        $Path,

        # Output Files
        [Parameter(Mandatory)]
        $OutKey
    )

    # Decode Secure String
    $sPassphrase = Unprotect-SecureString -SecureString $Passphrase

    if ($Rsa) {
        # PKCS1
        # Encrypt with AES256
        $sCmd = "`"$($OpenSslPath)`" rsa -aes256 -passin pass: -passout pass:$sPassphrase -in `"$($Path)`" -out `"$($OutKey)`""
    }
    else {
        # PKCS8
        # Encrypt with AES256 with hmacWithSHA256
        # https://www.openssl.org/docs/man1.1.0/man1/openssl-pkcs8.html
        $sCmd = "`"$($OpenSslPath)`" pkcs8 -topk8 -v2 aes-256-cbc -passin pass: -passout pass:$sPassphrase -in `"$($Path)`" -out `"$($OutKey)`""
    }

    # Execute Command
    Write-Verbose "Executing Command: $($sCmd)"
    $sResult = CMD.EXE /C $sCmd '2>&1'

    # TODO: Capture and parse OpenSSL response.
    if ($?) { Write-Verbose ($sResult | Out-String) }
    else { Throw ($sResult | Out-String) }

    return (Get-Item -Path $OutKey)
}


Function Unprotect-PrivateKey {
    <#
    .SYNOPSIS
    Removes encryption from a Private Key
    .PARAMETER OpenSslPath
    The path to the OpenSSL binary, openssl.exe.
    .PARAMETER Passphrase
    A passphrase to use for decryption of the Private Key.
    .PARAMETER Rsa
    Specifies that RSA (PKCS1) encryption format should be used.
    .PARAMETER Path
    The path to the encrypted, source Private Key.
    .PARAMETER OutKey
    The path for writing the decrypted Private Key.
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2019-06-30
    .LINK
    https://github.com/matthewschacherbauer
    https://www.matthewschacherbauer.com
    #>

    [CmdletBinding()]
    Param (
        [ValidateScript({Test-Path -Path $_})]
        [string] $OpenSslPath = $ENV:OpenSsl + "\bin\openssl.exe",

        # Encryption Option
        [Parameter(Mandatory)]
        [Securestring] $Passphrase,

        # Format
        [switch] $Rsa,

        # Source Files
        [Parameter(Mandatory)]
        $Path,

        # Output Files
        [Parameter(Mandatory)]
        $OutKey
    )

    # Decode Secure String
    $sPassphrase = Unprotect-SecureString -SecureString $Passphrase

    if ($Rsa) {
        # PKCS1
        # Strip app encryption
        $sCmd = "`"$($OpenSslPath)`" rsa -passin pass:$sPassphrase -in `"$($Path)`" -out `"$($OutKey)`""
    }
    else {
        # PKCS8
        # Strip app encryption
        # https://www.openssl.org/docs/man1.1.0/man1/openssl-pkcs8.html
        $sCmd = "`"$($OpenSslPath)`" pkcs8 -topk8 -nocrypt -passin pass:$sPassphrase -passout pass: -in `"$($Path)`" -out `"$($OutKey)`""
    }

    # Execute Command
    Write-Verbose "Executing Command: $($sCmd)"
    $sResult = CMD.EXE /C $sCmd '2>&1'

    # TODO: Capture and parse OpenSSL response.
    if ($?) { Write-Verbose ($sResult | Out-String) }
    else { Throw ($sResult | Out-String) }

    return (Get-Item -Path $OutKey)
}


Function Unprotect-SecureString {
    <#
    .SYNOPSIS
    Removes encryption from a SecureString variable and returns the encrypted password in plain text.
    .PARAMETER SecureString
    A SecureString value to unprotect.
    .OUTPUTS
    String.
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2019-06-30
    .LINK
    https://github.com/matthewschacherbauer
    https://www.matthewschacherbauer.com
    #>

    [CmdletBinding()]
    Param (
        [Parameter(Mandatory,Position=0,ValueFromPipeline)]
        [securestring] $SecureString
    )

    Begin {
        Write-Verbose "Call Unprotect-SecureString"
    }

    Process {
        # Decode Secure String
        $sSecureString = $SecureString | ConvertFrom-SecureString -ErrorAction Stop
        $sSecureString = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "NULL", ($sSecureString | ConvertTo-SecureString)
        $sSecureString = $sSecureString.GetNetworkCredential().Password

        $sSecureString
    }

    End { }
}


Function Remove-CertificateBagAttributes {
    <#
    .SYNOPSIS
    Removes Bag Attributes from a certificate.
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2019-06-30
    .LINK
    https://github.com/matthewschacherbauer
    https://www.matthewschacherbauer.com
    #>

    [CmdletBinding()]
    Param (
        [Parameter(Mandatory,Position=0,ValueFromPipeline)]
        $Certificate
    )

    Begin {
        Write-Verbose "Call Remove-CertificateBagAttributes"
    }

    Process {
        $Certificate | Where-Object {
            $_ -notlike "Bag Attributes*" -and `
            $_ -notlike "subject=*" -and `
            $_ -notlike "issuer=*" -and `
            $_ -notlike "" -and `
            $_ -notlike "    *" -and `
            $_ -notlike "Key *"
        }
    }

    End { }
}


Function ConvertTo-Der {
    <#
    .SYNOPSIS
    Converts various certificate formats to a DER certificate.
    .PARAMETER OpenSslPath
    The file path to the OpenSSL binary, openssl.exe.
    .PARAMETER SourceFormat
    The encoding format of the source certificate.
    .PARAMETER Path
    The file path to the source Certificate.
    .PARAMETER OutPath
    The directory path for writing the converted Certificate.
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2019-06-30
        
    Version:    2.0
    .LINK
    https://www.matthewschacherbauer.com
    #>

    [CmdletBinding()]
    Param (
        [ValidateScript({Test-Path -Path $_})]
        [string] $OpenSslPath = $ENV:OpenSsl + "\bin\openssl.exe",

        # Source Files
        [Parameter(Mandatory)]
        [ValidateSet("cer","crt","pem","x509","p7b","pkcs7")]
        [string] $SourceFormat,
        [Parameter(Mandatory)]
        [ValidateScript({Test-Path -Path $_})]
        [string] $Path,

        # Output Files
        [Parameter(Mandatory)]
        [string] $OutPath
    )

    Write-Verbose "Call ConvertTo-Der"

    # Resolve Parameters
    if ($Path) { $oPath = Get-Item -Path $Path -ErrorAction Stop }
    if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

    # Variables
    $ENV:RANDFILE = $ENV:USERPROFILE + "\.rnd"

    # Determine output file paths
    $sOutCert = $oOutPath.FullName + "\" + $oPath.BaseName + ".der"

    Switch ($SourceFormat) {
        {$_ -in "cer","crt","pem","x509"} { # .PEM
            $sCmd = "`"$($OpenSslPath)`" x509 -outform der -in `"$($oPath.FullName)`" -out `"$($sOutCert)`""
        }
        {$_ -in "p7b","pkcs7"} { #.P7B
            $sCmd = "`"$($OpenSslPath)`" pkcs7 -in `"$($oPath.FullName)`" -outform der -out `"$($sOutCert)`""
        }
        default { Throw "Unexpected Source Format" }
    }

    # Execute Command
    Write-Verbose "Executing Command: $($sCmd)"
    $sResult = CMD.EXE /C $sCmd '2>&1'

    # TODO: Capture and parse OpenSSL response.
    if ($?) { Write-Verbose ($sResult | Out-String) }
    else { Throw ($sResult | Out-String) }

    return (Get-Item -Path $sOutCert)
}


Function ConvertTo-JavaKeystore {
    <#
    .SYNOPSIS
    Converts a PFX formatted certificate to a Java Keystore format.
    .PARAMETER OpenSslPath
    The path to the OpenSSL binary, openssl.exe.
    .PARAMETER JavaPath
    The path to the Java JRE installation directory.
    .PARAMETER Passphrase
    A passphrase to use for encryption and decryption of the Private Key.
    The passphrase parameter is mandatory for the Java Keystore format.
    .PARAMETER Path
    The file path to the source Certificate.
    .PARAMETER OutPath
    The directory path for writing the converted Certificate.
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2019-06-30
        
    Version:    1.0

    The Java Keystore format requires a passphrase of at least six characters to be used.
    .LINK
    https://www.matthewschacherbauer.com
    https://www.openssl.org/docs/manmaster/man1/pkcs12.html
    #>

    [CmdletBinding()]
    Param (
        [ValidateScript({Test-Path -Path $_})]
        [string] $OpenSslPath = $ENV:OpenSsl + "\bin\openssl.exe",
        [Parameter(Mandatory)]
        [ValidateScript({Test-Path -Path $_})]
        [string] $JavaPath = $ENV:Java_Home,

        # Encryption Options
        [Parameter(Mandatory)]
        [securestring] $Passphrase,

        # Source Files
        [Parameter(Mandatory)]
        [ValidateScript({Test-Path -Path $_})]
        [string] $Path,

        # Output Files
        [Parameter(Mandatory)]
        [string] $OutPath
    )

    Write-Verbose "Call ConvertTo-JavaKeystore"

    # Resolve Parameters
    if ($Path) { $oPath = Get-Item -Path $Path -ErrorAction Stop }
    if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

    # Variables
    $ENV:RANDFILE   = $ENV:USERPROFILE + "\.rnd"
    $JavaKeytool    = $JavaPath + "\bin\keytool.exe"

    # Determine output file paths
    $sOutCert = $oOutPath.FullName + "\" + $oPath.BaseName + ".ks"

    # Check for Keytool utility.
    if (!(Test-Path -Path $JavaKeytool -ErrorAction SilentlyContinue)) {
        Throw "Java keytool.exe not found at path: ($($JavaKeytool))."
    }

    # Validate source CertFile
    if (!(Get-Item -Path $oPath.FullName -ErrorAction SilentlyContinue).Extension -eq ".pfx") {
        Throw "Source CertFile must be of type PFX."
    }

    # Check for Encrypted Source PFX
    if (!(isEncryptedPrivateKey -OpenSslPath $OpenSslPath -Path $oPath.FullName)) {
        Throw "The source PFX file must be encrypted."
    }

    # Decode Passphrase
    Write-Verbose "Decoding passphrase."
    $sPassphrase = Unprotect-SecureString -SecureString $Passphrase

    # Check passphrase length
    if ($sPassphrase.length -lt 6) { Throw "Passphrase length is not sufficient." }

    # Build the command line
    Write-Verbose "Building Java command."

    $sCmd = "`"$($JavaKeytool)`" -importkeystore -srckeystore `"$($oPath.FullName)`" -srcstoretype pkcs12 -srcstorepass `"$($sPassphrase)`" -destkeystore `"$($sOutCert)`" -deststoretype JKS -deststorepass `"$($sPassphrase)`""

    # Execute Command
    Write-Verbose "Executing Command: $($sCmd)"
    $sResult = CMD.EXE /C $sCmd '2>&1'

    # TODO: Capture and parse keytool response.
    if ($?) { Write-Verbose ($sResult | Out-String) }
    else { Throw ($sResult | Out-String) }

    # Return Data
    return [PrivateKey] @{
        "Encrypted"     = $True
        "Passphrase"    = $Passphrase
        "Path"          = $( if ($sOutCert) { Get-Item -Path $sOutCert } )
    }
}


Function ConvertTo-Pem {
    <#
    .SYNOPSIS
    Converts various certificate formats to a PEM certificate.
    .PARAMETER OpenSslPath
    The path to the OpenSSL binary, openssl.exe.
    .PARAMETER SourceFormat
    The encoding format of the source certificate.
    .PARAMETER Path
    The file path to the source Certificate.
    .PARAMETER OutPath
    The directory path for writing the converted Certificate.
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2019-06-30
        
    Version:    2.0
    .LINK
    https://www.matthewschacherbauer.com
    #>

    [CmdletBinding()]
    Param (
        [ValidateScript({Test-Path -Path $_})]
        [string] $OpenSslPath = $ENV:OpenSsl + "\bin\openssl.exe",

        # Source Files
        [Parameter(Mandatory)]
        [ValidateSet("cer","crt","pem","x509","p7b","pkcs7")]
        [string] $SourceFormat,
        [Parameter(Mandatory)]
        [ValidateScript({Test-Path -Path $_})]
        [string] $Path,

        # Output Files
        [Parameter(Mandatory)]
        [string] $OutPath
    )

    Write-Verbose "Call ConvertTo-Pem"

    # Resolve Parameters
    if ($Path) { $oPath = Get-Item -Path $Path -ErrorAction Stop }
    if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

    # Variables
    $ENV:RANDFILE = $ENV:USERPROFILE + "\.rnd"

    # Determine output file paths
    $sOutCert = $oOutPath.FullName + "\" + $oPath.BaseName + ".pem"

    Switch ($SourceFormat) {
        {$_ -in "cer","crt","pem","x509"} { # .CER
            $sCmd = "`"$($OpenSslPath)`" x509 -in `"$($oPath.FullName)`" -out `"$($sOutCert).tmp`""
        }
        {$_ -in "p7b","pkcs7"} { # .P7B
            $sCmd = "`"$($OpenSslPath)`" pkcs7 -print_certs -in `"$($oPath.FullName)`" -outform pem -out `"$($sOutCert).tmp`""
        }
        default { Throw "Unexpected Source Format" }
    }

    # Execute Command
    Write-Verbose "Executing Command: $($sCmd)"
    $sResult = CMD.EXE /C $sCmd '2>&1'

    # TODO: Capture and parse OpenSSL response.
    if ($?) { Write-Verbose ($sResult | Out-String) }
    else { Throw ($sResult | Out-String) }

    Get-Content "$($sOutCert).tmp" | Remove-CertificateBagAttributes | Set-Content "$($sOutCert)" -Encoding ASCII
    Remove-Item "$($sOutCert).tmp"

    return (Get-Item -Path $sOutCert)
}


Function ConvertTo-Pfx {
    <#
    .SYNOPSIS
    Converts various certificate formats to a PFX certificate.
    .PARAMETER OpenSslPath
    The path to the OpenSSL binary, openssl.exe.
    .PARAMETER Passphrase
    A passphrase to use for encryption and decryption of the Private Key.
    .PARAMETER Encrypt
    Indicates that the private key is encrypted and should be written in an encrypted format.
    .PARAMETER Cipher
    Speccifies the encoding cipher to be used.
    .PARAMETER Certificate
    The file path to the source Certificate.
    .PARAMETER Key
    The file path to the coresponding Private Key for the Certificate.
    .PARAMETER OutPath
    The directory path for writing the converted Certificate.
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2019-06-30
        
    Version:    2.0
    .LINK
    https://www.matthewschacherbauer.com
    https://www.openssl.org/docs/manmaster/man1/pkcs12.html
    #>

    [CmdletBinding()]
    Param (
        [ValidateScript({Test-Path -Path $_})]
        [string] $OpenSslPath = $ENV:OpenSsl + "\bin\openssl.exe",

        # Encryption Options
        [securestring] $Passphrase,
        [switch] $Encrypt,
        [ValidateSet('aes128','aes192','aes256','aria128','aria192','aris256','camellia128','camellia192','camellia256','des3')]
        [string] $Cipher = "aes256",

        # Source Files
        [Parameter(Mandatory)]
        [ValidateScript({Test-Path -Path $_})]
        [string] $Certificate,
        [Parameter(Mandatory)]
        [ValidateScript({Test-Path -Path $_})]
        [string] $Key,

        # Output Files
        [Parameter(Mandatory)]
        [string] $OutPath
    )

    Write-Verbose "Call ConvertTo-Pfx"

    # Resolve Parameters
    if ($Certificate) { $oCertificate = Get-Item -Path $Certificate -ErrorAction Stop }
    if ($Key) { $oKey = Get-Item -Path $Key -ErrorAction Stop }
    if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

    # Variables
    $ENV:RANDFILE = $ENV:USERPROFILE + "\.rnd"

    # Determine output file paths
    $sOutCertificate = $oOutPath.FullName + "\" + $oCertificate.BaseName + ".pfx"

    # Check for Encrypted Private Key
    if (!$Encrypt -and (isEncryptedPrivateKey -OpenSslPath $OpenSslPath -Path $oKey.FullName)) {
        Write-Verbose "Detected encrypted private key without encryption declared."
        $Encrypt = $true
    }

    # Check Encryption
    if ($Encrypt) {
        if (!$Passphrase) {
            Write-Verbose "Encryption requested without a supplied passphrase."
            $Passphrase = Read-Host "Private Key Passphrase" -AsSecureString
        }
        
        # Decode Passphrase
        Write-Verbose "Decoding passphrase."
        $sPassphrase = Unprotect-SecureString -SecureString $Passphrase
    }

    # Build the command line
    Write-Verbose "Building OpenSSL command."

    $sCmd = "`"$($OpenSslPath)`" pkcs12 -export -in `"$($oCertificate.FullName)`" -inkey `"$($oKey.FullName)`" -out `"$($sOutCertificate)`""

    if ($Encrypt) {
        Write-Verbose "Use encrypted private key."
        $sCmd += " -passin pass:`"$($sPassphrase)`" -passout pass:`"$($sPassphrase)`" -$($Cipher)"
    }
    else {
        Write-Verbose "Use plaintext private key."
        $sCmd += " -nodes -passout pass:"
    }

    # Execute Command
    Write-Verbose "Executing Command: $($sCmd)"
    $sResult = CMD.EXE /C $sCmd '2>&1'

    # TODO: Capture and parse OpenSSL response.
    if ($?) { Write-Verbose ($sResult | Out-String) }
    else { Throw ($sResult | Out-String) }

    # Return Data
    return [PrivateKey] @{
        "Encrypted"     = $Encrypt
        "Passphrase"    = $Passphrase
        "Path"          = $( if ($sOutCertificate) { Get-Item -Path $sOutCertificate } )
    }
}


Function ConvertTo-Pkcs1 {
    <#
    .SYNOPSIS
    Converts a PCKS8 Private Key to PKCS1.
    .PARAMETER OpenSslPath
    The path to the OpenSSL binary, openssl.exe.
    .PARAMETER Passphrase
    A passphrase to use for encryption and decryption of the Private Key.
    .PARAMETER Encrypt
    Indicates that the private key is encrypted and should be written in an encrypted format.
    .PARAMETER Path
    The file path to the Private Key.
    .PARAMETER OutPath
    The directory path for writing the converted Private Key.
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2019-06-30
        
    Version:    2.0
    .LINK
    https://www.matthewschacherbauer.com
    https://www.openssl.org/docs/manmaster/man1/rsa.html
    #>

    [CmdletBinding()]
    Param (
        [ValidateScript({Test-Path -Path $_})]
        [string] $OpenSslPath = $ENV:OpenSsl + "\bin\openssl.exe",

        # Encryption Options
        [securestring] $Passphrase,
        [switch] $Encrypt,
        [ValidateSet('aes128','aes192','aes256','aria128','aria192','aris256','camellia128','camellia192','camellia256','des3')]
        [string] $Cipher = "aes256",

        # Source Files
        [Parameter(Mandatory)]
        [ValidateScript({Test-Path -Path $_})]
        [string] $Path,

        # Output Files
        [string] $OutPath
    )

    Write-Verbose "Call ConvertTo-Pkcs1"

    # Resolve Parameters
    if ($Path) { $oPath = Get-Item -Path $Path -ErrorAction Stop }
    if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

    # Variables
    $ENV:RANDFILE = $ENV:USERPROFILE + "\.rnd"

    # Determine output file paths
    $sOutKey = $oOutPath.FullName + "\" + $oPath.BaseName + ".pkcs1.key"

    # Check for Encrypted Private Key
    if (!$Encrypt -and (isEncryptedPrivateKey -OpenSslPath $OpenSslPath -Path $oPath.FullName)) {
        Write-Verbose "Detected encrypted private key without encryption declared."
        $Encrypt = $true
    }

    # Check Encryption
    if ($Encrypt) {
        if (!$Passphrase) {
            Write-Verbose "Encryption requested without a supplied passphrase."
            $Passphrase = Read-Host "Private Key Passphrase" -AsSecureString
        }
        
        # Decode Passphrase
        Write-Verbose "Decoding passphrase."
        $sPassphrase = Unprotect-SecureString -SecureString $Passphrase
    }

    # Build the command line
    Write-Verbose "Building OpenSSL command."

    $sCmd = "`"$($OpenSslPath)`" rsa -in `"$($oPath.FullName)`""

    if ($Encrypt) {
        Write-Verbose "Use encrypted private key."
        $sCmd += " -passin pass:`"$($sPassphrase)`" -passout pass:`"$($sPassphrase)`" -$($Cipher)"
    }
    else {
        Write-Verbose "Use plaintext private key."
        #$sCmd += ""
    }

    Write-Verbose "Write data to file."
    $sCmd += " -out `"$($sOutKey)`""

    # Execute Command
    Write-Verbose "Executing Command: $($sCmd)"
    $sResult = CMD.EXE /C $sCmd '2>&1'

    # TODO: Capture and parse OpenSSL response.
    if ($?) { Write-Verbose ($sResult | Out-String) }
    else { Throw ($sResult | Out-String) }

    # Return Data
    return [PrivateKey] @{
        "Encrypted"     = $Encrypt
        "Passphrase"    = $Passphrase
        "Path"          = $( if ($sOutKey) { Get-Item -Path $sOutKey } )
    }
}


Function ConvertTo-Pkcs8 {
    <#
    .SYNOPSIS
    Converts a PKCS1 Private Key to PKCS8.
    .PARAMETER OpenSslPath
    The path to the OpenSSL binary, openssl.exe.
    .PARAMETER Passphrase
    A passphrase to use for encryption and decryption of the Private Key.
    .PARAMETER Encrypt
    Indicates that the private key is encrypted and should be written in an encrypted format.
    .PARAMETER Path
    The file path to the Private Key.
    .PARAMETER OutPath
    The directory path for writing the converted Private Key.
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2019-06-30
        
    Version:    2.0
    .LINK
    https://www.matthewschacherbauer.com
    https://www.openssl.org/docs/man1.0.2/man1/openssl-pkcs8.html
    #>

    [CmdletBinding()]
    Param (
        [ValidateScript({Test-Path -Path $_})]
        [string] $OpenSslPath = $ENV:OpenSsl + "\bin\openssl.exe",

        # Encryption Options
        [securestring] $Passphrase,
        [switch] $Encrypt,

        # Source Files
        [Parameter(Mandatory)]
        [ValidateScript({Test-Path -Path $_})]
        [string] $Path,

        # Output Files
        [string] $OutPath
    )

    Write-Verbose "Call ConvertTo-Pkcs8"

    # Resolve Parameters
    if ($Path) { $oPath = Get-Item -Path $Path -ErrorAction Stop }
    if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

    # Variables
    $ENV:RANDFILE = $ENV:USERPROFILE + "\.rnd"

    # Determine output file paths
    $sOutKey = $oOutPath.FullName + "\" + $oPath.BaseName + ".pkcs8.key"

    # Check for Encrypted Private Key
    if (!$Encrypt -and (isEncryptedPrivateKey -OpenSslPath $OpenSslPath -Path $oPath.FullName)) {
        Write-Verbose "Detected encrypted private key without encryption declared."
        $Encrypt = $true
    }

    # Check Encryption
    if ($Encrypt) {
        if (!$Passphrase) {
            Write-Verbose "Encryption requested without a supplied passphrase."
            $Passphrase = Read-Host "Private Key Passphrase" -AsSecureString
        }
        
        # Decode Passphrase
        Write-Verbose "Decoding passphrase."
        $sPassphrase = Unprotect-SecureString -SecureString $Passphrase
    }

    # Build the command line
    Write-Verbose "Building OpenSSL command."

    $sCmd = "`"$($OpenSslPath)`" pkcs8 -topk8 -in `"$($oPath.FullName)`""

    if ($Encrypt) {
        Write-Verbose "Use encrypted private key."
        $sCmd += " -passin pass:`"$($sPassphrase)`" -passout pass:`"$($sPassphrase)`" -v2 des3 -v2prf hmacWithSHA256"
    }
    else {
        Write-Verbose "Use plaintext private key."
        $sCmd += " -nocrypt"
    }

    Write-Verbose "Write data to file."
    $sCmd += " -out `"$($sOutKey)`""

    # Execute Command
    Write-Verbose "Executing Command: $($sCmd)"
    $sResult = CMD.EXE /C $sCmd '2>&1'

    # TODO: Capture and parse OpenSSL response.
    if ($?) { Write-Verbose ($sResult | Out-String) }
    else { Throw ($sResult | Out-String) }

    # Return Data
    return [PrivateKey] @{
        "Encrypted"     = $Encrypt
        "Passphrase"    = $Passphrase
        "Path"          = $( if ($sOutKey) { Get-Item -Path $sOutKey } )
    }
}


Function Get-EnterpriseCAList {
    <#
    .SYNOPSIS
    Retrieves the list of Enterprise Certificate Authorities from Active Directory.
    .PARAMETER AdcsTemplate
    Filter the list to include only Certificate Authorities that issue the specified Template.
    .PARAMETER AdcsDnsName
    Filter the list to include only Certificate Authorities whose DNS name includes the specified string.
    This is not a literal match.
    .PARAMETER AdcsName
    Filter the list to include only Certificate Authorities whose Name includes the specified string.
    This is not a literal match.
    .PARAMETER Online
    Filter the list to include only Certificate Authorities that respond to a ping request with Test-Connection.
    If the Certificate Authority is proxied by a Certificate Enrollment Services (CES) server, then this will cause the CES server to be tested instead.
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2022-02-24
        
    Version:    1.0.1
    .LINK
    https://www.matthewschacherbauer.com
    #>

    #Requires -Modules ActiveDirectory

    [CmdletBinding()]
    Param (
        [string] $AdcsTemplate,
        [string] $AdcsDnsName,
        [string] $AdcsName,
        [switch] $Online
    )

    Write-Verbose "Call Get-EnterpriseCaList"

    # Get a list of Enterprise Certificate Authorities from Active Directory
    # Get-ADObject requires Active Directory RSAT to be installed.
    # TODO: Implement an alternative which does not require the RSAT.
    $sEnrollmentDN = "CN=Enrollment Services,CN=Public Key Services,CN=Services,CN=Configuration,$([System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest().RootDomain.GetDirectoryEntry().distinguishedName)"
    $oEnrollmentServices = Get-ADObject -SearchBase $sEnrollmentDN -LDAPFilter "(objectClass=pKIEnrollmentService)" -Properties dNSHostName,certificateTemplates,msPKI-Enrollment-Servers |
        Select-Object dNSHostName,Name,DistinguishedName,cACertificateDN,CN,certificateTemplates,msPKI-Enrollment-Servers,ObjectGUID

    Write-Verbose "Found $($oEnrollmentServices.count) Certificate Authorities."

    # Filter the results based on Certificate Authority DNS Name
    if ($AdcsDNSName) {
        Write-Verbose "Limiting Certificate Authorities to those matching the name ($($AdcsDNSName))."
        $oEnrollmentServices = $oEnrollmentServices | Where-Object { $_.dNSHostName -like "*$($AdcsDNSName)*" }
        Write-Verbose "Found $($oEnrollmentServices.count) Certificate Authorities."
    }

    # Filter the results based on Certificate Authority Name
    if ($AdcsName) {
        Write-Verbose "Limiting Certificate Authorities to those matching the name ($($AdcsName))."
        $oEnrollmentServices = $oEnrollmentServices | Where-Object { $_.Name -like "*$($AdcsName)*" }
        Write-Verbose "Found $($oEnrollmentServices.count) Certificate Authorities."
    }

    # Filter the results to include only ADCS endpoints that offer the requested template.
    if ($AdcsTemplate) {
        Write-Verbose "Limiting Certificate Authorities to those issuing the template ($($AdcsTemplate))."
        $oEnrollmentServices = $oEnrollmentServices | Where-Object { $_.certificateTemplates -contains $AdcsTemplate }
        Write-Verbose "Found $($oEnrollmentServices.count) Certificate Authorities."
    }

    # Filter the results to include only ADCS endpoints that are online.
    if ($Online) {
        Write-Verbose "Limiting Certificate Authorities to those passing Test-Connection."

        $oEnrollmentServices = foreach ($thisAdcsEndpoint in $oEnrollmentServices) {
            # Test the connection to the CA
            # If the CA is behind an Enrollment Server, then test the connection to the Enrollment Server instead.
            Write-Verbose "Testing CA $($thisAdcsEndpoint.dNSHostName)"
            if (${thisAdcsEndpoint.msPKI-Enrollment-Servers}) {
                # Test Connection to Enrollment Server
                $sAdcsEndpoint = (${thisAdcsEndpoint.msPKI-Enrollment-Servers} | Where-Object { $_ -like "http*" }.Split("\")[2])
                Write-Verbose "Querying Enrollment Server $sAdcsEndpoint"
                if (Test-Connection $sAdcsEndpoint -Count 1 -Quiet) {
                    $thisAdcsEndpoint
                }
                else { continue }
            }
            else {
                # Test Connection to Certificate Authority
                Write-Verbose "Querying Certificate Authority $($thisAdcsEndpoint.dNSHostName)"
                if (Test-Connection $thisAdcsEndpoint.dNSHostName -Count 1 -Quiet) {
                    $thisAdcsEndpoint
                }
                else { continue }
            }
        }

        Write-Verbose "Found $($oEnrollmentServices.count) Certificate Authorities."
    }

    return $oEnrollmentServices
}


Function Find-CertificateIssuingEnterpriseCA {
    <#
    .SYNOPSIS
    Searches for the source Enterprise Certificate Authority that issued a given certificate.
    Must be run by a user with read privileges on the Enterprise Certificate Authority.
    #>

    [CmdletBinding()]
    Param (
        [string] $SerialNumber,
        [string] $Path,
        [switch] $AsString
    )

    Write-Verbose "Call Find-CertificateIssuingEnterpriseCA"

    if ($SerialNumber) {
        # Get all Enterprise Certificate Authorities
        $oEnterpriseCAList = Get-EnterpriseCAList -Online

        # Test-EnterpriseCertificateAuthoritySignature and check for an existing certificate
        # Really not expecting to get more than one match here.
        $oIssuingCA = foreach ($oThisEnterpriseCA in $oEnterpriseCAList) {
            if ( (Test-EnterpriseCertificateAuthoritySignature -SerialNumber $SerialNumber -AdcsServer "$($oThisEnterpriseCA.dNSHostName)\$($oThisEnterpriseCA.Name)").Status -eq "valid") {
                $oThisEnterpriseCA
            }
        }
    }

    if ($Path) {
        # Read the certificate
        $oCertificate = ReadCertificateFromFile -Path $Path
        if (!$oCertificate.Issuer) { Throw "No certificate could be loaded." }

        # Extract the Issuing CA
        $sCertificateIssuer = $oCertificate.Issuer.Split("=")[1].Split(",")[0]

        # Get-EnterpriseCaList with filters
        $oIssuingCA = Get-EnterpriseCAList -AdcsName $sCertificateIssuer
    }

    if (!$oIssuingCA) {
        return $null
    }

    if ($AsString) {
        return "$($oIssuingCA.dNSHostName)\$($oIssuingCA.Name)"
    }

    return $oIssuingCA
}


Function Export-CaChain {
    <#
    .SYNOPSIS
    Exports a certificate authority chain file from a source certificate.
    Essentially, spits out only the parents of a given certificate.
    .PARAMETER OpenSslPath
    The path to the OpenSSL binary, openssl.exe.
    .PARAMETER Passphrase
    A passphrase to use for decryption of the Private Key.
    .PARAMETER Encrypt
    Indicates that the private key is encrypted and should be written in an encrypted format.
    .PARAMETER SourceFormat
    The encoding format of the source certificate.
    .PARAMETER Path
    The file path to the source Certificate.
    .PARAMETER OutPath
    The directory path for writing the exported Certificate Authority chain.
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2019-06-30
        
    Version:    2.0
    .LINK
    https://www.matthewschacherbauer.com
    #>

    [CmdletBinding()]
    Param (
        [ValidateScript({Test-Path -Path $_})]
        [string] $OpenSslPath = $ENV:OpenSsl + "\bin\openssl.exe",

        # Encryption Options
        [securestring] $Passphrase,
        [switch] $Encrypt,

        # Source Files
        [Parameter(Mandatory)]
        [ValidateSet("pfx","pkcs12")]
        $SourceFormat,
        [Parameter(Mandatory)]
        [ValidateScript({Test-Path -Path $_})]
        $Path,

        # Output Files
        [Parameter(Mandatory)]
        $OutPath
    )

    Write-Verbose "Call Export-CaChain"

    # Resolve Parameters
    if ($Path) { $oPath = Get-Item -Path $Path -ErrorAction Stop }
    if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

    # Variables
    $ENV:RANDFILE = $ENV:USERPROFILE + "\.rnd"

    # Determine output file paths
    $sOutFile = "$($oOutPath.FullName)" + "\" + "cachain.pem"

    # Check for Encrypted Private Key
    if (!$Encrypt -and (isEncryptedPrivateKey -OpenSslPath $OpenSslPath -Path $oPath.FullName)) {
        Write-Verbose "Detected encrypted private key without encryption declared."
        $Encrypt = $true
    }

    # Check Encryption
    if ($Encrypt) {
        if (!$Passphrase) {
            Write-Verbose "Encryption requested without a supplied passphrase."
            $Passphrase = Read-Host "Private Key Passphrase" -AsSecureString
        }
        
        # Decode Passphrase
        Write-Verbose "Decoding passphrase."
        $sPassphrase = Unprotect-SecureString -SecureString $Passphrase

        $encryptString = " -passin pass:$($sPassphrase) -passout pass:$($sPassphrase)"
    }
    else {
        Write-Verbose "Use plaintext private key."
        $encryptString = " -nodes -passin pass:"
    }

    Switch ($SourceFormat) {
        {$_ -in "pfx","pkcs12"} { # .PFX
            $sCmd = "`"$($OpenSslPath)`" pkcs12 -in `"$($oPath.FullName)`" -cacerts -nokeys $($encryptString) -out `"$($sOutFile).tmp`""
        }
        default { Throw "Unexpected Source Format" }
    }

    # Execute Command
    Write-Verbose "Executing Command: $($sCmd)"
    $sResult = CMD.EXE /C $sCmd '2>&1'

    # TODO: Capture and parse keytool response.
    if ($?) { Write-Verbose ($sResult | Out-String) }
    else { Throw ($sResult | Out-String) }

    if ( (Get-Item "$($sOutFile).tmp").length -eq 0) {
        Write-Error "No CA Chain file was exported! Verify that the certificate chain contains at least one parent certificate."
        Remove-Item "$($sOutFile).tmp"
        return
    }

    Get-Content "$($sOutFile).tmp" | Remove-CertificateBagAttributes | Set-Content "$($sOutFile)" -Encoding ASCII
    Remove-Item "$($sOutFile).tmp"

    # Return Data
    return (Get-Item -Path $sOutFile)
}


Function New-OpenSslCertificateConfiguration {
    <#
    .SYNOPSIS
    Creates a configuration file for a new RSA Public/Private KeyPair.
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2021-08-10
        
    Version:    1.4
    .LINK
    https://www.matthewschacherbauer.com
    https://www.openssl.org/docs/man1.0.2/man5/x509v3_config.html
    #>

    [CmdletBinding()]
    Param (
        [Parameter(Mandatory)]
        [string[]] $Hostname,
        [string[]] $Ip,
        [ValidateSet('1024','2048','3072','4096')]
        [int] $Bits = $Global:DefaultAdcsBits,

        [string[]] $BasicContraints = @("CA:false"),
        [ValidateSet('critical','digitalSignature','nonRepudiation','keyEncipherment','dataEncipherment','keyAgreement','keyCertSign','cRLSign','encipherOnly','decipherOnly')]
        [string[]] $KeyUsage = @("digitalSignature","keyEncipherment"),
        [ValidateSet('critical','serverAuth','clientAuth','codeSigning','emailProtection','timeStamping','msCodeInd','msCodeCom','msCTLSign','msSGC','msEFS','nsSGC')]
        [string[]] $ExtendedKeyUsage = @("serverAuth","clientAuth"),

        # Encryption Options
        [switch] $Encrypt,

        # Distinguished Name
        [ValidateNotNullOrEmpty()]
        [string] $OrganizationalUnit = $Global:DefaultAdcsOrganizationUnit,
        [ValidateNotNullOrEmpty()]
        [string] $Organization = $Global:DefaultAdcsOrganization,
        [string] $StreetAddress = $Global:DefaultAdcsStreetAddress,
        [string] $PostalCode = $Global:DefaultAdcsPostalCode,
        [ValidateNotNullOrEmpty()]
        [string] $Locality = $Global:DefaultAdcsLocality,
        [ValidateNotNullOrEmpty()]
        [string] $State = $Global:DefaultAdcsState,
        [ValidateNotNullOrEmpty()]
        [string] $CountryName = $Global:DefaultAdcsCountryName,
        [string[]] $Email = $Global:DefaultAdcsEmail,

        # Include Email in subjectAltName Attribute
        [switch] $IncludeEmailInSan
    )

    Write-Verbose "Call New-OpenSslCertificateConfiguration"

    # Format the encryption value
    if ($Encrypt) { $sEncrypt = "yes" }
    else { $sEncrypt = "no" }

    # Format the SAN attribute
    # Valid attributes: DNS, IP, email, otherName, UTF8, URI, dirName, RID
    foreach ($thisHost in $Hostname) {
        if ($sanList) { $sanList += "," }
        $sanList += "DNS:$($thisHost)"
    }
    foreach ($thisIp in $Ip) {
        if ($sanList) { $sanList += "," }
        $sanList += "IP:$($thisIp)"
    }
    if ($Email -and $IncludeEmailInSan) {
        foreach ($thisEmail in $Email) {
            if ($sanList) { $sanList += "," }
            $sanList += "email:$($thisEmail)"
        }
    }

    # Format the BasicConstraints
    foreach ($thisBasicConstraint in $BasicContraints) {
        if ($sBasicConstraints) { $sBasicConstraints += "," }
        $sBasicConstraints += "$($thisBasicConstraint)"
    }

    # Format the KeyUsage
    foreach ($thisKeyUsage in $KeyUsage) {
        if ($sKeyUsage) { $sKeyUsage += "," }
        $sKeyUsage += "$($thisKeyUsage)"
    }

    # Format the ExtendedKeyUsage
    foreach ($thisExtendedKeyUsage in $ExtendedKeyUsage) {
        if ($sExtendedKeyUsage) { $sExtendedKeyUsage += "," }
        $sExtendedKeyUsage += "$($thisExtendedKeyUsage)"
    }

    $config = "# OpenSSL configuration to generate a new key with signing request for a x509v3
# multidomain certificate

[ req ]
default_bits       = $($Bits)
default_md         = sha512
prompt             = no
encrypt_key        = $($sEncrypt)
#string_mask       = nombstr

# base request
distinguished_name = req_distinguished_name

# extensions
req_extensions     = v3_req

# distinguished_name
[ req_distinguished_name ]
countryName            = `"$($CountryName)`"             # C=
stateOrProvinceName    = `"$($State)`"                   # ST=
localityName           = `"$($Locality)`"                # L=
$( if (!$PostalCode) { "#" } )postalCode            = `"$($PostalCode)`"              # L/postalcode=
$( if (!$StreetAddress) { "#" } )streetAddress         = `"$($StreetAddress)`"           # L/street=
organizationName       = `"$($Organization)`"            # O=
organizationalUnitName = `"$($OrganizationalUnit)`"  # OU=
commonName             = `"$($Hostname[0])`"             # CN=
$( if (!$Email) { "#" } )emailAddress           = `"$($Email[0])`"                   # CN/emailAddress=

# req_extensions
[ v3_req ]
# Key Restrictions
basicConstraints       = $($sBasicConstraints)
keyUsage               = $($sKeyUsage)
extendedKeyUsage       = $($sExtendedKeyUsage)

# The subject alternative name extension allows various literal values to be 
# included in the configuration file
# http://www.openssl.org/docs/apps/x509v3_config.html
subjectAltName  = $($sanList)"

    return $config
}


Function New-CertificateSigningRequest {
    <#
    .SYNOPSIS
    Generates a new private key and PKCS10 certificate signing request.
    .PARAMETER OpenSslPath
    The path to the OpenSSL binary, openssl.exe.
    .PARAMETER Config
    The file path to the OpenSSL configuration file.

    This parameter is mutually exclusive with the following parameters:
    CountryName, State, Locality, PostalCode, StreetAddress, Organization, OrganizationalUnit, Email, Bits
    .PARAMETER Hostname
    A string array of hostnames to include in the subjectAltName of the Certificate.
    The first hostname in the array will also be used for the CommonName value on the Certificate.
    .PARAMETER Ip
    A string array of IPs to include in the subjectAltName of the Certificate.
    .PARAMETER Bits
    The key length to generate.
    .PARAMETER OrganizationalUnit
    The OrganizationalUnit value on the Certificate
    OU=
    .PARAMETER Organization
    The Organization value on the Certificate
    O=
    .PARAMETER StreetAddress
    The StreetAddress value on the Certificate
    L/street=
    .PARAMETER PostalCode
    The PostalCode value on the Certificate
    L/postalcode=
    .PARAMETER Locality
    The Locality value on the Certificate
    L=
    .PARAMETER State
    The State value on the Certificate
    S=
    .PARAMETER CountryName
    The CountryName value on the Certificate
    C=
    .PARAMETER Email
    The EmailAddress value on the Certificate
    CN/emailAddress=
    .PARAMETER Passphrase
    A passphrase to use for decryption of the Private Key.
    .PARAMETER Encrypt
    Indicates that the private key is encrypted and should be written in an encrypted format.
    .PARAMETER OutPath
    The directory path for writing the Private Key and Certificate Signing Request.
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2020-01-30
        
    Version:    2.1
    .LINK
    https://www.matthewschacherbauer.com
    https://www.openssl.org/docs/manmaster/man1/req.html
    #>

    [CmdletBinding()]
    Param (
        [ValidateScript({Test-Path -Path $_})]
        [string] $OpenSslPath = $ENV:OpenSsl + "\bin\openssl.exe",

        # Certificate Options
        [Parameter(ParameterSetName="ConfigIn")]
        [string] $Config,
        [Parameter(Mandatory,Position=0)]
        [ValidateNotNullOrEmpty()]
        [string[]] $Hostname,
        [string[]] $Ip,
        [Parameter(ParameterSetName="ConfigGen")]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('1024','2048','3072','4096')]
        [int] $Bits = $Global:DefaultAdcsBits,
        [Parameter(ParameterSetName="ConfigGen")]
        [ValidateNotNullOrEmpty()]
        [string] $OrganizationalUnit = $Global:DefaultAdcsOrganizationUnit,
        [Parameter(ParameterSetName="ConfigGen")]
        [ValidateNotNullOrEmpty()]
        [string] $Organization = $Global:DefaultAdcsOrganization,
        [Parameter(ParameterSetName="ConfigGen")]
        [string] $StreetAddress = $Global:DefaultAdcsStreetAddress,
        [Parameter(ParameterSetName="ConfigGen")]
        [string] $PostalCode = $Global:DefaultAdcsPostalCode,
        [Parameter(ParameterSetName="ConfigGen")]
        [ValidateNotNullOrEmpty()]
        [string] $Locality = $Global:DefaultAdcsLocality,
        [Parameter(ParameterSetName="ConfigGen")]
        [ValidateNotNullOrEmpty()]
        [string] $State = $Global:DefaultAdcsState,
        [Parameter(ParameterSetName="ConfigGen")]
        [ValidateNotNullOrEmpty()]
        [string] $CountryName = $Global:DefaultAdcsCountryName,
        [Parameter(ParameterSetName="ConfigGen")]
        [string[]] $Email = $Global:DefaultAdcsEmail,

        # Include Email in subjectAltName Attribute
        [switch] $IncludeEmailInSan,

        # Encryption Options
        [securestring] $Passphrase,
        [switch] $Encrypt,

        # Output Options
        [Parameter(Mandatory)]
        [string] $OutPath
    )

    Write-Verbose "Call New-CertificateSigningRequest"

    # Resolve Parameters
    if ($Config) { $oConfig = Get-Item -Path $Config -ErrorAction Stop }
    if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

    # Variables
    $ENV:RANDFILE = $ENV:USERPROFILE + "\.rnd"

    # Determine output file paths
    $sOutKey = $oOutPath.FullName + "\" + $Hostname[0].Replace('*','') + ".key"
    $sOutRequest = $oOutPath.FullName + "\" + $Hostname[0].Replace('*','') + ".csr"

    # Check Encryption
    if ($Encrypt) {
        if (!$Passphrase) {
            Write-Verbose "Encryption requested without a supplied passphrase."
            $Passphrase = Read-Host "Private Key Passphrase" -AsSecureString
        }
        
        # Decode Passphrase
        Write-Verbose "Decoding passphrase."
        $sPassphrase = Unprotect-SecureString -SecureString $Passphrase
    }

    # Import or generate a request configuration file
    if ($oConfig) {
        Write-Verbose "Using input OpenSSL configuration file: $($oConfig.FullName)"

        # TODO: Parse configuration file to read the key size.
    }
    else {
        $sConfig = $oOutPath.FullName + "\" + $Hostname[0].Replace('*','') + ".cfg"
        Write-Verbose "Generating new OpenSSL configuration file with input parameters. Using path: $($sConfig)"
        New-OpenSslCertificateConfiguration `
            -Hostname $Hostname `
            -Ip $Ip `
            -OrganizationalUnit $OrganizationalUnit `
            -Organization $Organization `
            -StreetAddress $StreetAddress `
            -PostalCode $PostalCode `
            -Locality $Locality `
            -State $State `
            -CountryName $CountryName `
            -Email $Email `
            -IncludeEmailInSan:$IncludeEmailInSan `
            -Bits $Bits `
            -Encrypt:$Encrypt `
            -ErrorAction Stop |
            Out-File -FilePath $sConfig -Encoding ASCII -ErrorAction Stop
        $oConfig = Get-Item -Path $sConfig -ErrorAction Stop
    }

    # Build the command line
    Write-Verbose "Building OpenSSL command."
    $sCmd = "`"$($OpenSslPath)`" req -new -newkey rsa:$($Bits) -config `"$($oConfig.FullName)`""

    if ($Encrypt) {
        Write-Verbose "Generate private key with encryption."
        $sCmd += " -passout pass:`"$($sPassphrase)`""
    }
    else {
        Write-Verbose "Generate private key without encryption."
        $sCmd += " -nodes"
    }

    Write-Verbose "Write data to file."
    $sCmd += " -keyout `"$($sOutKey)`" -out `"$($sOutRequest)`""

    # Execute Command
    Write-Verbose "Executing Command: $($sCmd)"
    $sResult = CMD.EXE /C $sCmd '2>&1'

    # TODO: Capture and parse OpenSSL response.
    if ($?) { Write-Verbose ($sResult | Out-String) }
    else { Throw ($sResult | Out-String) }

    # Return Data
    return [PSCustomObject] @{
        "PrivateKey"                = [PrivateKey] @{
            "Encrypted"             = $Encrypt
            "Passphrase"            = $Passphrase
            "Path"                  = $( if ($sOutKey) { Get-Item -Path $sOutKey } )
        }

        "CertificateRequest"        = [PSCustomObject] @{
            "Config"                = $oConfig
            "Path"                  = $( if ($sOutRequest) { Get-Item -Path $sOutRequest } )
        }
    }
}


Function New-SelfSignedCertificate {
    <#
    .SYNOPSIS
    Generates a self signed certificate using a provate key and certificate signing request file.
    .PARAMETER OpenSslPath
    The path to the OpenSSL binary, openssl.exe.
    .PARAMETER Passphrase
    A passphrase to use for decryption of the Private Key.
    .PARAMETER Encrypt
    Indicates that the private key is encrypted and should be written in an encrypted format.
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2019-06-29
        
    Version:    2.0
    .LINK
    https://www.matthewschacherbauer.com
    https://www.openssl.org/docs/manmaster/man1/x509.html
    #>

    [CmdletBinding()]
    Param (
        [ValidateScript({Test-Path -Path $_})]
        [string] $OpenSslPath = $ENV:OpenSsl + "\bin\openssl.exe",

        # Options
        [Parameter(Mandatory)]
        [int] $ValidityDays,

        # Encryption Options
        [securestring] $Passphrase,
        [switch] $Encrypt,

        # Source Files
        [Parameter(Mandatory)]
        [ValidateScript({Test-Path -Path $_})]
        [string] $Config,
        [Parameter(Mandatory)]
        [ValidateScript({Test-Path -Path $_})]
        [string] $Key,
        [Parameter(Mandatory)]
        [ValidateScript({Test-Path -Path $_})]
        [string] $Request,

        # Output Files
        [Parameter(Mandatory)]
        [string] $OutPath
    )

    Write-Verbose "Call New-SelfSignedCertificate"

    # Resolve Parameters
    if ($Config) { $oConfig = Get-Item -Path $Config -ErrorAction Stop }
    if ($Key) { $oKey = Get-Item -Path $Key -ErrorAction Stop }
    if ($Request) { $oRequest = Get-Item -Path $Request -ErrorAction Stop }
    if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

    # Variables
    $ENV:RANDFILE = $ENV:USERPROFILE + "\.rnd"

    # Determine output file paths
    $sOutCert = $oOutPath.FullName + "\" + $oRequest.BaseName + ".selfsigned.cer"
    $sOutCertChain = $oOutPath.FullName + "\" + $oRequest.BaseName + ".selfsigned.chain.p7b"

    # Check for Encrypted Private Key
    if (!$Encrypt -and (isEncryptedPrivateKey -OpenSslPath $OpenSslPath -Path $oKey.FullName)) {
        Write-Verbose "Detected encrypted private key without encryption declared."
        $Encrypt = $true
    }

    # Check Encryption
    if ($Encrypt) {
        if (!$Passphrase) {
            Write-Verbose "Encryption requested without a supplied passphrase."
            $Passphrase = Read-Host "Private Key Passphrase" -AsSecureString
        }
        
        # Decode Passphrase
        Write-Verbose "Decoding passphrase."
        $sPassphrase = Unprotect-SecureString -SecureString $Passphrase
    }

    # Build the command line
    Write-Verbose "Building OpenSSL command."

    $sCmd = "`"$($OpenSslPath)`" x509 -signkey `"$($oKey.FullName)`" -req -days $($ValidityDays) -extfile `"$($oConfig.FullName)`" -extensions v3_req -in `"$($oRequest.FullName)`""

    if ($Encrypt) {
        Write-Verbose "Use encrypted private key."
        $sCmd += " -passin pass:`"$($sPassphrase)`""
    }
    else {
        Write-Verbose "Use plaintext private key."
        #$sCmd += ""
    }

    Write-Verbose "Write data to file."
    $sCmd += " -out `"$($sOutCert)`""

    # Execute Command
    Write-Verbose "Executing Command: $($sCmd)"
    $sResult = CMD.EXE /C $sCmd '2>&1'

    # TODO: Capture and parse OpenSSL response.
    if ($?) { Write-Verbose ($sResult | Out-String) }
    else { Throw ($sResult | Out-String) }

    # Convert the resulting cert to P7B
    Write-Verbose "Converting the resulting certificate to an empty chain."
    $sCmd = "`"$($OpenSslPath)`" crl2pkcs7 -nocrl -certfile `"$($sOutCert)`" -out `"$($sOutCertChain)`""

    # Execute Command
    Write-Verbose "Executing Command: $($sCmd)"
    $sResult = CMD.EXE /C $sCmd '2>&1'

    # TODO: Capture and parse OpenSSL response.
    if ($?) { Write-Verbose ($sResult | Out-String) }
    else { Throw ($sResult | Out-String) }

    # Return Data
    return [PSCustomObject] @{
        "PrivateKey"            = [PrivateKey] @{
            "Encrypted"         = $Encrypt
            "Passphrase"        = $Passphrase
            "Path"              = $oKey
        }

        "Certificate"           = $( if ($sOutCert) { Get-Item -Path $sOutCert } )
        "CertificateChain"      = $( if ($sOutCertChain) { Get-Item -Path $sOutCertChain } )
    }
}


Function New-EnterpriseCertificateAuthoritySignature {
    <#
    .SYNOPSIS
    Submits a Certificate Signing Request to an Active Directory Certificate Authority.
    .DESCRIPTION
    New-EnterpriseCertificateAuthoritySignature submits a Certificate Signing Request to an Active Directory Certificate Authority for signing, then saves the resulting signed Certificate, Certificate Chain, and Response files.
    .PARAMETER AdcsServer
    The Active Directory Certificate Authority server to submit the Enterprise Signing Request to.
    This should be formatted for use by CERTREQ: FQDN\CA Name

    Example,
    WSNOCCA01.lan.wolfspirit.net\WolfSpirit-Net-WSNOCCA01-CA
    .PARAMETER AdcsTemplate
    The Active Directory Certificate Authority Certificate Template to use in the request.
    This should be formatted for use by CERTREQ, use the template name and not the template display name.
    .PARAMETER SetSanHostname
    Provide one or more hostnames to be written to the Subject Alternative Name attribute.
    Using this parameter will discard any SAN attribute that exists in the certificate request.
    The Enterprise CA must support +EDITF_ATTRIBUTESUBJECTALTNAME2
    .PARAMETER SetSanIp
    Provide one or more IP Addresses to be written to the Subject Alternative Name attribute.
    Using this parameter will discard any SAN attribute that exists in the certificate request.
    The Enterprise CA must support +EDITF_ATTRIBUTESUBJECTALTNAME2
    .PARAMETER SetSanEmail
    Provide one or more email address to be written to the Subject Alternative Name attribute.
    Using this parameter will discard any SAN attribute that exists in the certificate request.
    The Enterprise CA must support +EDITF_ATTRIBUTESUBJECTALTNAME2
    .PARAMETER SanReplacementMode
    Sets the handling for SAN attribute modifications. May be either "Merge" or "Replace".
    Merge mode will append any specified SAN attributes to the end of what exists on the signing request.
    Replace mode will discard all SAN attributes in the signing request.
    .PARAMETER Path
    The file path to the Certificate Signing Request (CSR) file that should be submitted to the Certificate Authority for signing.
    .PARAMETER OutPath
    The directory path for writing the signed Certificate, Certificate Chain, and Response files.
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2021-08-13
        
    Version:    2.6
    .LINK
    https://www.matthewschacherbauer.com
    #>

    [CmdletBinding()]
    Param (
        # Options
        [string] $AdcsServer = $Global:DefaultAdcsServer,
        [ValidateNotNullOrEmpty()]
        [string] $AdcsTemplate = $Global:DefaultAdcsTemplate,

        # Appended Attributes
        # Note: The Enterprise CA must support +EDITF_ATTRIBUTESUBJECTALTNAME2
        [string[]] $SetSanHostname,
        [string[]] $SetSanIp,
        [string[]] $SetSanEmail,

        # Subject Alternative Name Mode
        [ValidateSet("Merge","Replace")]
        [string] $SanReplacementMode = "Replace",

        # Override Hash Algorithm
        #[ValidateSet('SHA256','SHA384','SHA512')]
        #[string] $HashAlgorithm,

        # Source Files
        [Parameter(Mandatory)]
        [ValidateScript({Test-Path -Path $_})]
        [string] $Path,

        # Output Files
        [Parameter(Mandatory)]
        [string] $OutPath
    )

    Write-Verbose "Call New-EnterpriseCertificateAuthoritySignature"

    # Resolve Parameters
    if ($Path) { $oPath = Get-Item -Path $Path -ErrorAction Stop }
    if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

    # Determine output file paths
    $sOutCert = $oOutPath.FullName + "\" + $oPath.BaseName + ".cer"
    $sOutChainP7b = $oOutPath.FullName + "\" + $oPath.BaseName + ".chain.p7b"
    $sOutChainRsp = $oOutPath.FullName + "\" + $oPath.BaseName + ".chain.rsp"

    # Select an available ADCS resource
    if (!$AdcsServer) {
        Write-Verbose "Querying for an available ADCS Server"
        $oAdcsServer = Get-EnterpriseCAList -AdcsTemplate $AdcsTemplate -Online | Get-Random

        if (!$oAdcsServer) {
            Throw "Unable to locate any online Active Directory Certificate Authority that issues the certificate template ($($AdcsTemplate))."
        }

        $AdcsServer = "$($oAdcsServer.dNSHostName)\$($oAdcsServer.Name)"
        Write-Verbose "Selected ADCS Server ($($AdcsServer))"
    }

    # Retrieve the SAN attributes in the request
    if ($SanReplacementMode -eq "Merge") {
        Write-Verbose "Merging SAN attributes in signing request with override values"
        $oCsrAttributes = DecodeCsrWithOpenssl -Path $oPath.FullName

        Write-Verbose "Retrieved the following SAN attributes from the request file:"
        Write-Verbose "Hostnames: $($oCsrAttributes.SAN.DNS | Out-String)"
        Write-Verbose "IP: $($oCsrAttributes.SAN.IP | Out-String)"
        Write-Verbose "Email: $($oCsrAttributes.SAN.Email | Out-String)"

        if ($oCsrAttributes.SAN.DNS) {
            $SetSanHostname = $oCsrAttributes.SAN.DNS + $SetSanHostname
        }

        if ($oCsrAttributes.SAN.IP) {
            $SetSanIp = $oCsrAttributes.SAN.IP + $SetSanIp
        }

        if ($oCsrAttributes.SAN.Email) {
            $SetSanEmail = $oCsrAttributes.SAN.Email + $SetSanEmail
        }
    }

    # Dynamically build -attrib parameter
    $sAttributes = "CertificateTemplate:$($AdcsTemplate)"
    if ($SetSanHostname -or $SetSanIp -or $SetSanEmail) {
        $sAttributes += "\nSAN:"
        $i = 0
        if ($SetSanHostname) {
            foreach ($thisHostname in $SetSanHostname) {
                if ($i -gt 0) { $sAttributes += "&" }
                $sAttributes += "DNS=$($thisHostname)"
                $i++
            }
        }
        if ($SetSanIp) {
            foreach ($thisIp in $SetSanIp) {
                if ($i -gt 0) { $sAttributes += "&" }
                $sAttributes += "IPADDRESS=$($thisIp)"
                $i++
            }
        }
        if ($SetSanEmail) {
            foreach ($thisEmail in $SetSanEmail) {
                if ($i -gt 0) { $sAttributes += "&" }
                $sAttributes += "EMAIL=$($thisEmail)"
                $i++
            }
        }
    }
    #if ($HashAlgorithm) {
    #    $sAttributes += "\nHashAlgorithm:$($HashAlgorithm)"
    #}
    Write-Verbose "Constructed attribute string: $($sAttributes)"

    # Submit CertReq to Certificate Authority.
    # Receive and write out the Certificate, Certificate Chain, and Request Response files.
    $sCmd = "`"$ENV:WINDIR\System32\CERTREQ.EXE`" -attrib `"$($sAttributes)`" -config `"$($AdcsServer)`" -submit `"$($oPath.FullName)`" `"$($sOutCert)`" `"$($sOutChainP7b)`" `"$($sOutChainRsp)`""

    # Execute Command
    Write-Verbose "Executing Command: $($sCmd)"
    $sResult = CMD.EXE /C $sCmd '2>&1'

    # TODO: Capture and parse CertReq response.
    if ($?) { Write-Verbose ($sResult | Out-String) }
    else { Throw ($sResult | Out-String) }

    # Parse CertReq response for RequestID.
    $sCertificateRequestId = ($sResult | Where-Object {$_ -like "*RequestId*"}).Split(" ")[1]
    $sCertificateStatus = ($sResult | Where-Object {$_ -like "*Certificate retrieved*"}).Split(" ")[2]

    # Return Data
    return [PSCustomObject] @{
        "AdcsTemplate"          = $AdcsTemplate
        "AdcsServer"            = $AdcsServer

        "Request"               = [PSCustomObject] @{
            "Status"            = $sCertificateStatus
            "ID"                = $sCertificateRequestId
        }

        "Certificate"           = [PSCustomObject] @{
            "CER"               = $( if ($sOutCert) { Get-Item -Path $sOutCert } )
        }

        "CertificateChain"      = [PSCustomObject] @{
            "P7B"               = $( if ($sOutChainP7b) { Get-Item -Path $sOutChainP7b } )
            "RSP"               = $( if ($sOutChainRsp) { Get-Item -Path $sOutChainRsp } )
        }
    }
}


Function Test-EnterpriseCertificateAuthoritySignature {
    <#
    .SYNOPSIS
    Tests a certificate signed by an Enterprise Certificate Authority.
    .PARAMETER AdcsServer
    The Active Directory Certificate Authority server to submit the Enterprise Signing Request to.
    This should be formatted for use by CERTREQ: FQDN\CA Name

    Example,
    WSNOCCA01.lan.wolfspirit.net\WolfSpirit-Net-WSNOCCA01-CA
    .PARAMETER SerialNumber
    The Certificate Serial Number to test for validity against the Enterprise Certificate Authority.
    .PARAMETER Path
    The path to the Certificate file to test for validity.
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2021-02-11

    Version:    1.0
    .LINK
    https://www.matthewschacherbauer.com
    #>

    [CmdletBinding()]
    Param (
        # Options
        [ValidateNotNullOrEmpty()]
        [string] $AdcsServer = $Global:DefaultAdcsServer,

        # Serial Number Source
        [Parameter(Mandatory,ParameterSetName="TestSerial")]
        [string] $SerialNumber,

        # Certificate Source
        [Parameter(Mandatory,ParameterSetName="TestCertificate")]
        [ValidateScript({Test-Path -Path $_})]
        [string] $Path
    )

    Write-Verbose "Call Test-EnterpriseCertificateAuthoritySignature"

    # Resolve Parameters
    if ($Path) { $oPath = Get-Item -Path $Path -ErrorAction Stop }

    # If ParameterSet TestCertificate, retrieve the Certificate Serial Number
    # Then, validate the Certificate Serial Number
    if ($oPath) {
        # Import the certificate
        $certificateFile = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Certificate2
        $certificateFile.Import($oPath)

        # Retrieve the certificate serial number
        [String] $sCertificateSerial = $certificateFile.SerialNumber
    }

    # If ParameterSet TestSerial, validate the Certifiate Serial Number
    if ($SerialNumber) {
        [String] $sCertificateSerial = $SerialNumber
    }

    # Submit IsValid Check to Certificate Authority.
    $sCmd = "`"$ENV:WINDIR\System32\CERTUTIL.EXE`" -config `"$($AdcsServer)`" -isvalid $($sCertificateSerial)"

    # Execute Command
    Write-Verbose "Executing Command: $($sCmd)"
    $sResult = CMD.EXE /C $sCmd '2>&1'

    # TODO: Capture and parse CertUtil response.
    if ($?) { Write-Verbose ($sResult | Out-String) }
    else { Throw ($sResult | Out-String) }

    # Return Data
    return [PSCustomObject] @{
        "AdcsServer"            = $AdcsServer
        "SerialNumber"          = $sCertificateSerial
        "Status"                = $sResult[0].Split(" ")[5]
    }
        
}


Function Revoke-EnterpriseCertificateAuthoritySignature {
    <#
    .SYNOPSIS
    Revokes a certificate signed by an Enterprise Certificate Authority.
    .DESCRIPTION
    The Revoke-EnterpriseCertificateAuthoritySignature cmdlet issues a REVOKE request using the CERTUTIL utility to an Enterprise Certificate Authority.
    If successful, the certificate or certificate serial number provided will be revoked by the Certificate Authority.

    This command is not effective if proper Certificate Revocation Lists are not maintained and accessible by clients.
    With exception to Certificate Hold, this command is irreversable.
    .PARAMETER AdcsServer
    The Active Directory Certificate Authority server to submit the Enterprise Signing Request to.
    This should be formatted for use by CERTREQ: FQDN\CA Name

    Example,
    WSNOCCA01.lan.wolfspirit.net\WolfSpirit-Net-WSNOCCA01-CA
    .PARAMETER SerialNumber
    The Certificate Serial Number to revoke on the Enterprise Certificate Authority.
    .PARAMETER Path
    The path to the Certificate file which contains the certificate to be revoked.
    .PARAMETER Reason
    Specify the reason number (0-6) for the Certificate Revocation.

    0: CRL_REASON_UNSPECIFIED               -- Unspecified (default)
    1: CRL_REASON_KEY_COMPROMISE            -- Key Compromise
    2: CRL_REASON_CA_COMPROMISE             -- CA Compromise
    3: CRL_REASON_AFFILIATION_CHANGED       -- Affiliation Changed
    4: CRL_REASON_SUPERSEDED                -- Superseded
    5: CRL_REASON_CESSATION_OF_OPERATION    -- Cessation of Operation
    6: CRL_REASON_CERTIFICATE_HOLD          -- Certificate Hold
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2021-03-35

    Version:    1.0.1
    .LINK
    https://github.com/matthewschacherbauer
    https://www.matthewschacherbauer.com
    #>

    [CmdletBinding(SupportsShouldProcess,ConfirmImpact="High")]
    Param (
        # Options
        [ValidateNotNullOrEmpty()]
        [string] $AdcsServer,

        # Serial Number Source
        [Parameter(Mandatory,ParameterSetName="RevokeSerial")]
        [string] $SerialNumber,

        # Certificate Source
        [Parameter(Mandatory,ParameterSetName="RevokeCertificate")]
        [ValidateScript({Test-Path -Path $_})]
        [string] $Path,

        # Revoke Reason
        [Parameter(Mandatory)]
        [ValidateSet("0","1","2","3","4","5","6")]
        [int] $Reason,

        [switch] $Force
    )

    Write-Verbose "Call Revoke-EnterpriseCertificateAuthoritySignature"

    # Resolve Parameters
    if ($Path) { $oPath = Get-Item -Path $Path -ErrorAction Stop }

    # If ParameterSet RevokeCertificate, retrieve the Certificate Serial Number
    # Then, validate the Certificate Serial Number
    if ($oPath) {
        # Import the certificate
        $certificateFile = ReadCertificateFromFile -Path $oPath.FullName

        # Retrieve the certificate serial number
        [String] $sCertificateSerial = $certificateFile.GetSerialNumberString()

        # Locate the Issuing CA
        if (!$AdcsServer) {
            $AdcsServer = Find-CertificateIssuingEnterpriseCA -Path $oPath.FullName -AsString
        }
    }

    # If ParameterSet RevokeSerial, validate the Certifiate Serial Number
    if ($SerialNumber) {
        [String] $sCertificateSerial = $SerialNumber

        # Attempt to locate the Issuing CA
        if (!$AdcsServer) {
            $AdcsServer = Find-CertificateIssuingEnterpriseCA -SerialNumber $sCertificateSerial -AsString
        }
    }

    # Verify a Certificate Authority was specified
    if (!$AdcsServer) {
        Throw "No Enterprise Certificate Authority could be found for the specified Certificate. Verify the CA is available and online."
    }

    # Check Certificate Status
    $sCertificateStatus = Test-EnterpriseCertificateAuthoritySignature -AdcsServer $AdcsServer -SerialNumber $sCertificateSerial

    if ($sCertificateStatus.Status -eq "revoked") {
        Write-Warning "Certificate with serial number $sCertificateSerial is already revoked."

        return [PSCustomObject] @{
            "AdcsServer"            = $AdcsServer
            "SerialNumber"          = $sCertificateSerial
            "Status"                = "Revoked"
        }
    }
    elseif ($sCertificateStatus.Status -ne "valid") {
        Write-Warning "Certificate with serial number $sCertificateSerial is not valid: $sCertificateStatus"

        return [PSCustomObject] @{
            "AdcsServer"            = $AdcsServer
            "SerialNumber"          = $sCertificateSerial
            "Status"                = "Invalid"
        }
    }

    # Submit Revocation Request to Certificate Authority.
    $sCmd = "`"$ENV:WINDIR\System32\CERTUTIL.EXE`" -config `"$($AdcsServer)`" -revoke $sCertificateSerial $Reason"

    # Execute Command
    if ($Force -or $PSCmdlet.ShouldContinue("Revoke certificate with Serial Number $($sCertificateSerial) on CA $($AdcsServer)?", "Confirm Certificate Revocation")) {
        Write-Verbose "Executing Command: $($sCmd)"
        $sResult = CMD.EXE /C $sCmd '2>&1'

        # TODO: Capture and parse CertUtil response.
        if ($?) { Write-Verbose ($sResult | Out-String) }
        else { Throw ($sResult | Out-String) }

        # Return Data
        return [PSCustomObject] @{
            "AdcsServer"            = $AdcsServer
            "SerialNumber"          = $sCertificateSerial
            "Status"                = "Revoked"
        }
    }
    else {
        # Return Data
        return [PSCustomObject] @{
            "AdcsServer"            = $AdcsServer
            "SerialNumber"          = $sCertificateSerial
            "Status"                = "Skipped"
        }
    }



}


Function Complete-CertificateSigningRequest {
    <#
    .SYNOPSIS
    Completes a new certificate signing request using the Private Key and the signed Certificate from an issuing Certificate Authority.
    .DESCRIPTION
    Complete-CertificateSigningRequest combines the Private Key with the signed Certificate and converts the result to various formats for use.
    The signed Certificate and Certificate Chain files and their matching Private Key are required.
    .PARAMETER OpenSslPath
    The file path to the OpenSSL binary, openssl.exe.
    .PARAMETER JavaPath
    The directory path to the Java JRE installation.
    .PARAMETER Passphrase
    A passphrase to use for encryption and decryption of the Private Key.
    If the source Private Key is encrypted, this parameter is required.
    .PARAMETER Encrypt
    Indicates that the private key is encrypted and should be written in an encrypted format.
    .PARAMETER Certificate
    The file path to the signed Certificate returned by the Certificate Authority.
    .PARAMETER CertificateChain
    The file path to the signed Certificate Chain returned by the Certificate Authority.
    .PARAMETER Key
    The file path to the coresponding Private Key for the Certificate.
    .PARAMETER OutPath
    The directory path for writing the completed Certificate package.
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2019-06-30

    Version:    1.0
    .LINK
    https://www.matthewschacherbauer.com
    #>

    [CmdletBinding()]
    Param (
        [ValidateScript({Test-Path -Path $_})]
        [string] $OpenSslPath = $ENV:OpenSsl + "\bin\openssl.exe",
        [ValidateScript({Test-Path -Path $_})]
        [string] $JavaPath = $ENV:Java_Home,

        # Encryption Options
        [securestring] $Passphrase,
        [switch] $Encrypt,

        # Source Files
        [ValidateScript({Test-Path $_ })]
        [string] $Certificate,
        [Parameter(Mandatory)]
        [ValidateScript({Test-Path $_ })]
        [string] $CertificateChain,
        [Parameter(Mandatory)]
        [ValidateScript({Test-Path $_ })]
        [string] $Key,

        # Output Files
        [string] $OutPath
    )

    Write-Verbose "Call Complete-CertificateSigningRequest"

    # Resolve Parameters
    if ($Certificate) { $oCertificate = Get-Item -Path $Certificate -ErrorAction Stop }
    if ($CertificateChain) { $oCertificateChain = Get-Item -Path $CertificateChain -ErrorAction Stop }
    if ($Key) { $oKey = Get-Item -Path $Key -ErrorAction Stop }
    if ($OutPath) { $oOutPath = Get-Item -Path $OutPath -ErrorAction Stop }

    # Variables
    $ENV:RANDFILE = $ENV:USERPROFILE + "\.rnd"

    # Check for Encrypted Private Key
    if (!$Encrypt -and (isEncryptedPrivateKey -OpenSslPath $OpenSslPath -Path $oKey.FullName)) {
        Write-Verbose "Detected encrypted private key without encryption declared."
        $Encrypt = $true
    }

    # Check Encryption
    if ($Encrypt) {
        if (!$Passphrase) {
            Write-Verbose "Encryption requested without a supplied passphrase."
            $Passphrase = Read-Host "Private Key Passphrase" -AsSecureString
        }
    }

    # Convert the certificate file (without chain).
    # This process is optional.
    if ($oCertificate) {
        try {
            # Convert the Signed x509 Certificate to PEM
            # This is a direct copy. We run it through OpenSsl anyways to ensure the certificate parses.
            $oResultPem = ConvertTo-Pem `
                -OpenSslPath $OpenSslPath `
                -SourceFormat "x509" `
                -Path $oCertificate `
                -OutPath $oOutPath `
                -ErrorAction Stop

            # Convert the PEM Certificate to DER
            $oResultDer = ConvertTo-Der `
                -OpenSslPath $OpenSslPath `
                -SourceFormat "pem" `
                -Path $oCertificate `
                -OutPath $oOutPath `
                -ErrorAction Continue
        }
        catch { Write-Warning "Failed to convert non-chain certificate." }
    }

    # Convert the PKCS7 (.p7b) Certificate Chain to PEM
    $oResultPemChain = ConvertTo-Pem `
        -OpenSslPath $OpenSslPath `
        -SourceFormat "pkcs7" `
        -Path $oCertificateChain `
        -OutPath $oOutPath `
        -ErrorAction Stop

    # Convert the PKCS7 (.p7b) Certificate Chain to DER
    try {
        $oResultDerChain = ConvertTo-Der `
            -OpenSslPath $OpenSslPath `
            -SourceFormat "pkcs7" `
            -Path $oCertificateChain `
            -OutPath $oOutPath `
            -ErrorAction Continue
    }
    catch { Write-Warning "Failed to convert the certificate to binary format." }

    # Combine the PEM Certificate Chain with the Private Key to PKCS12 (.pfx) with the Private Key
    $oResultPfx = ConvertTo-Pfx `
        -OpenSslPath $OpenSslPath `
        -Encrypt:$Encrypt `
        -Passphrase $Passphrase `
        -Certificate $oResultPemChain `
        -Key $oKey `
        -OutPath $oOutPath `
        -ErrorAction Stop

    # Convert PKCS12 (.pfx) to Java Keystore (.KS) with the Private Key
    if ($JavaPath -and $Passphrase) {
        try {
            $oResultKs = ConvertTo-JavaKeystore `
                -OpenSslPath $OpenSslPath `
                -JavaPath $JavaPath `
                -Passphrase $Passphrase `
                -Path $oResultPfx.Path `
                -OutPath $oOutPath `
                -ErrorAction Continue
        }
        catch { Write-Warning "Failed to convert the certificate to JKS format." }
    }
    else { Write-Warning "Skipped Java Keystore format. Requirements not met." }

    # Create the CA Chain file
    try {
        $oResultCaChain = Export-CaChain `
            -OpenSslPath $OpenSslPath `
            -Encrypt:$Encrypt `
            -Passphrase $Passphrase `
            -SourceFormat "pkcs12" `
            -Path $oResultPfx.Path `
            -OutPath $oOutPath `
            -ErrorAction Continue
    }
    catch { Write-Warning "Failed to export a CA Chain." }

    # Return Data
    return [PSCustomObject] @{
        "PrivateKey"        = [PrivateKey] @{
            "Encrypted"     = $Encrypt
            "Passphrase"    = $Passphrase
            "Path"          = $oKey
        }

        "Certificate"       = [PSCustomObject] @{
            "DER"           = $oResultDer
            "PEM"           = $oResultPem
        }

        "CertificateChain"  = [PSCustomObject] @{
            "DER"           = $oResultDerChain
            "KS"            = $oResultKs.Path
            "PEM"           = $oResultPemChain
            "PFX"           = $oResultPfx.Path
        }

        "CaChain"           = $oResultCaChain
    }
}


Function New-CertificatePackage {
    <#
    .SYNOPSIS
    Creates a new RSA Public/Private KeyPair, submits the certificate for a signature, and converts the resulting certificate to several popular formats.
    .PARAMETER OpenSslPath
    The path to the OpenSSL binary, openssl.exe.
    .PARAMETER JavaPath
    The path to the Java JRE installation directory.
    .PARAMETER Config
    The file path to the OpenSSL configuration file.

    This parameter is mutually exclusive with the following parameters:
    CountryName, State, Locality, PostalCode, StreetAddress, Organization, OrganizationalUnit, Email, Bits
    .PARAMETER Hostname
    A string array of hostnames to include in the subjectAltName of the Certificate.
    The first hostname in the array will also be used for the CommonName value on the Certificate.
    .PARAMETER Ip
    A string array of IPs to include in the subjectAltName of the Certificate.
    .PARAMETER Bits
    The key length to generate.
    .PARAMETER OrganizationalUnit
    The OrganizationalUnit value on the Certificate
    OU=
    .PARAMETER Organization
    The Organization value on the Certificate
    O=
    .PARAMETER StreetAddress
    The StreetAddress value on the Certificate
    L/street=
    .PARAMETER PostalCode
    The PostalCode value on the Certificate
    L/postalcode=
    .PARAMETER Locality
    The Locality value on the Certificate
    L=
    .PARAMETER State
    The State value on the Certificate
    S=
    .PARAMETER CountryName
    The CountryName value on the Certificate
    C=
    .PARAMETER Email
    The EmailAddress value on the Certificate
    The first email will be used in the certificate subject.
    If -IncludeEmailInSan is specified, all email addresses are added to the SAN attribute.
    CN/emailAddress=
    .PARAMETER IncludeEmailInSan
    Include all email addresses in the certificate SAN attribute.
    The default is false.
    .PARAMETER ValidityDays
    The number of days the Certificate should be valid for.
    This value may be overridden by the signing Certificate Authority.
    .PARAMETER AdcsServer
    The Active Directory Certificate Authority server to submit the Enterprise Signing Request to.
    This should be formatted for use by CERTREQ: FQDN\CA Name
    If not specified, the module will randomly select an Enterprise CA that offers the requested certificate.
    .PARAMETER AdcsTemplate
    The Active Directory Certificate Authority Certificate Template to use in the request.
    This should be formatted for use by CERTREQ, use the template name and not the template display name.
    .PARAMETER Passphrase
    A passphrase to use for encryption of the Private Key.
    .PARAMETER Encrypt
    Indicates that the private key is encrypted and should be written in an encrypted format.
    .PARAMETER OutPath
    The directory path for writing the Certificate Package.
    .EXAMPLE
    Generates a certificate package for test.wolfspirit.net.

    New-CertificatePackage -Bits 4096 -CountryName US -State California -Locality Sacramento -Organization "WolfSpirit.Net" -OrganizationalUnit "Test Lab" -AdcsServer "WSNOCCA20.lan.wolfspirit.net\WolfSpirit.Net RSA SHA256 Issuing CA 20" -AdcsTemplate "WS-RSA-WebServer-v3" -ValidityDays 365 -Hostname "test.wolfspirit.net" -OutPath "C:\Certificates"
    .EXAMPLE
    Generates a multi-domain certificate.

    New-CertificatePackage -Bits 4096 -CountryName US -State California -Locality Sacramento -Organization "WolfSpirit.Net" -OrganizationalUnit "Test Lab" -AdcsServer "WSNOCCA20.lan.wolfspirit.net\WolfSpirit.Net RSA SHA256 Issuing CA 20" -AdcsTemplate "WS-RSA-WebServer-v3" -ValidityDays 365 -Hostname "test.wolfspirit.net","www.test.wolfspirit.net","test-2.wolfspirit.net" -OutPath "C:\Certificates"
    .NOTES
    Author:     Matthew Schacherbauer
    Updated:    2022-05-12

    Version:    2.1.3
    #>

    [CmdletBinding()]
    Param (
        # Resources
        [ValidateScript({Test-Path -Path $_})]
        [string] $OpenSslPath = $ENV:OpenSsl + "\bin\openssl.exe",
        [ValidateScript({Test-Path -Path $_})]
        [string] $JavaPath = $ENV:Java_Home,

        # Certificate Options
        # Global values are set by a domain-wide PowerShell Profile script.
        [Parameter(Mandatory,ParameterSetName="ConfigIn")]
        [string] $Config,
        [Parameter(Mandatory,Position=0)]
        [ValidateNotNullOrEmpty()]
        [string[]] $Hostname,
        [string[]] $Ip,
        [Parameter(ParameterSetName="DataIn")]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('1024','2048','3072','4096')]
        [int] $Bits = $Global:DefaultAdcsBits,
        [Parameter(ParameterSetName="DataIn")]
        [ValidateNotNullOrEmpty()]
        [string] $OrganizationalUnit = $Global:DefaultAdcsOrganizationUnit,
        [Parameter(ParameterSetName="DataIn")]
        [ValidateNotNullOrEmpty()]
        [string] $Organization = $Global:DefaultAdcsOrganization,
        [Parameter(ParameterSetName="DataIn")]
        [string] $StreetAddress = $Global:DefaultAdcsStreetAddress,
        [Parameter(ParameterSetName="DataIn")]
        [string] $PostalCode = $Global:DefaultAdcsPostalCode,
        [Parameter(ParameterSetName="DataIn")]
        [ValidateNotNullOrEmpty()]
        [string] $Locality = $Global:DefaultAdcsLocality,
        [Parameter(ParameterSetName="DataIn")]
        [ValidateNotNullOrEmpty()]
        [string] $State = $Global:DefaultAdcsState,
        [Parameter(ParameterSetName="DataIn")]
        [ValidateNotNullOrEmpty()]
        [string] $CountryName = $Global:DefaultAdcsCountryName,
        [Parameter(ParameterSetName="DataIn")]
        [string[]] $Email = $Global:DefaultAdcsEmail,

        # Include Email in subjectAltName Attribute
        [switch] $IncludeEmailInSan,

        # Self-Signed Certificate Length
        [ValidateNotNullOrEmpty()]
        [int] $ValidityDays = $Global:DefaultAdcsValidity,

        # Active Directory Certificate Services Options
        [string] $AdcsServer,
        [ValidateNotNullOrEmpty()]
        [string] $AdcsTemplate = $Global:DefaultAdcsTemplate,

        # Encryption Options
        [securestring] $Passphrase,
        [switch] $Encrypt,

        # Output Files
        [ValidateScript({Test-Path -Path $_})]
        [string] $OutPath = $Global:DefaultAdcsPath
    )

    Write-Verbose "Call New-CertificatePackage"

    # Create certificate directory
    Write-Verbose "Creating certificate output directory."
    Write-Progress -Id 1 -Activity "Creating Certificate Package for $($Hostname[0])" -Status "Creating Output Directory" -PercentComplete 0
    $sOutPath = $OutPath + "\" + $Hostname[0].Replace('*','')
    New-Item -ItemType Directory -Path $sOutPath -ErrorAction Inquire | Out-Null

    # Resolve Parameters
    if ($Config) { $oConfig = Get-Item -Path $Config -ErrorAction Stop }
    if ($OutPath) { $oOutPath = Get-Item -Path $sOutPath -ErrorAction Stop }

    # Select an available ADCS resource
    Write-Progress -Id 1 -Activity "Creating Certificate Package for $($Hostname[0])" -Status "Querying for an Available ADCS Server" -PercentComplete 5
    if (!$AdcsServer) {
        Write-Verbose "Querying for an available ADCS Server"
        $oAdcsServer = Get-EnterpriseCAList -AdcsTemplate $AdcsTemplate -Online | Get-Random
        $AdcsServer = "$($oAdcsServer.dNSHostName)\$($oAdcsServer.Name)"
        Write-Verbose "Selected ADCS Server ($($AdcsServer))"
    }
    else { Write-Verbose "Using ADCS Server ($($AdcsServer))" }

    # Check Encryption
    Write-Verbose "Verifying encryption state"
    Write-Progress -Id 1 -Activity "Creating Certificate Package for $($Hostname[0])" -Status "Verifying Encryption State" -PercentComplete 15
    if ($Encrypt -and (!$Passphrase)) {
        Write-Verbose "Encryption requested without a supplied passphrase."
        $Passphrase = Read-Host "Private Key Passphrase" -AsSecureString
    }

    # Create Private Key and CSR
    Write-Progress -Id 1 -Activity "Creating Certificate Package for $($Hostname[0])" -Status "Generating Certificate Signing Request" -PercentComplete 20
    $p = @{
        'OpenSslPath'       = $OpenSslPath
        'Hostname'          = $Hostname
        'Ip'                = $Ip
        'Encrypt'           = $Encrypt
        'Passphrase'        = $Passphrase
        'OutPath'           = $oOutPath
    }
    if ($oConfig) { $p.Add('Config',$oConfig) }
    else {
        $p.Add('OrganizationalUnit',$OrganizationalUnit)
        $p.Add('Organization',$Organization)
        $p.Add('StreetAddress',$StreetAddress)
        $p.Add('PostalCode',$PostalCode)
        $p.Add('Locality',$Locality)
        $p.Add('State',$State)
        $p.Add('CountryName',$CountryName)
        $p.Add('Email',$Email)
        $p.Add('IncludeEmailInSan',$IncludeEmailInSan)
        $p.Add('Bits',$Bits)
    }
    $oResultCsr = New-CertificateSigningRequest @p -ErrorAction Stop

    # Convert the Private Key to PKCS1 Format
    Write-Progress -Id 1 -Activity "Creating Certificate Package for $($Hostname[0])" -Status "Converting the Private Key" -PercentComplete 30
    try {
        $p = @{
            'OpenSslPath'       = $OpenSslPath
            'Encrypt'           = $Encrypt
            'Passphrase'        = $Passphrase
            'Path'              = $oResultCsr.PrivateKey.Path
            'OutPath'           = $oOutPath
        }
        $oResultRsa = ConvertTo-Pkcs1 @p -ErrorAction Continue
    }
    catch { Write-Warning "Failed to convert Private Key to RSA format." }

    # Use the Private Key to create a Self Signed Certificate
    Write-Progress -Id 1 -Activity "Creating Certificate Package for $($Hostname[0])" -Status "Creating Self-Signed Test Certificate" -PercentComplete 35
    try {
        $p = @{
            'OpenSslPath'       = $OpenSslPath
            'ValidityDays'      = $ValidityDays
            'Encrypt'           = $Encrypt
            'Passphrase'        = $Passphrase
            'Config'            = $oResultCsr.CertificateRequest.Config
            'Key'               = $oResultCsr.PrivateKey.Path
            'Request'           = $oResultCsr.CertificateRequest.Path
            'OutPath'           = $oOutPath
        }
        $oResultSelfSigned = New-SelfSignedCertificate @p -ErrorAction Continue
    }
    catch { Write-Warning "Failed to generate a self-signed certificate." }

    # Submit the CSR to an Enterprise CA for Signing
    # Returns a signed x509 certificate, a PKCS7 certificate chain, and a RSP certificate chain
    Write-Progress -Id 1 -Activity "Creating Certificate Package for $($Hostname[0])" -Status "Requesting Enterprise ADCS Signing" -PercentComplete 40
    $p = @{
        'AdcsTemplate'      = $AdcsTemplate
        'AdcsServer'        = $AdcsServer
        'Path'              = $oResultCsr.CertificateRequest.Path
        'OutPath'           = $oOutPath
    }
    $oResultEnterpriseCa = New-EnterpriseCertificateAuthoritySignature @p -ErrorAction Stop


    # Combine the signed certificate issued by Active Directory with the Private Key
    # and convert the resulting certificate to various formats.
    Write-Progress -Id 1 -Activity "Creating Certificate Package for $($Hostname[0])" -Status "Performing Conversions" -PercentComplete 80
    $p = @{
        'OpenSslPath'           = $OpenSslPath
        'Encrypt'               = $Encrypt
        'Passphrase'            = $Passphrase
        'Certificate'           = $oResultEnterpriseCa.Certificate.CER
        'CertificateChain'      = $oResultEnterpriseCa.CertificateChain.P7B
        'Key'                   = $oResultCsr.PrivateKey.Path
        'OutPath'               = $oOutPath
    }
    if ($JavaPath) { $p.Add('JavaPath', $JavaPath) }
    $oResultCertificatePackage = Complete-CertificateSigningRequest @p -ErrorAction Stop

    Write-Progress -Id 1 -Activity "Creating Certificate Package for $($Hostname[0])" -Completed

    # Return Generated Certificate Paths                                                #   EXTENSION       FORMAT      HAS CHAIN       HAS PRIVATE KEY
    return [PSCustomObject] @{                                                          #   =========       ======      =========       ===============
        "PrivateKey"            = $oResultCsr.PrivateKey                                #   .KEY            PKCS8       NO              YES (Private Key Only)
        "PrivateKeyRsa"         = $oResultRsa                                           #   .RSA.KEY        PKCS1       NO              YES (Private Key Only)
        "CertificateConfig"     = $oResultCsr.CertificateRequest.Config                 #   .CFG
        "Request"               = [PSCustomObject] @{
            "Path"              = $oResultCsr.CertificateRequest.Path                   #   .CSR
            "Status"            = $oResultEnterpriseCa.Request.Status
            "ID"                = $oResultEnterpriseCa.Request.ID
        }
        "SelfCertificate"       = [PSCustomObject] @{
            "CER"               = $oResultSelfSigned.Certificate                        #   .SELF.CER       x509        NO              NO
            "P7B"               = $oResultSelfSigned.CertificateChain                   #   .SELF.P7B       PKCS7       YES             NO
        }
        "Certificate"           = [PSCustomObject] @{
            "CER"               = $oResultEnterpriseCa.Certificate.CER                  #   .CER            x509        NO              NO  (Source from ADCS)
            "DER"               = $oResultCertificatePackage.Certificate.DER            #   .DER            DER         NO              NO
            "PEM"               = $oResultCertificatePackage.Certificate.PEM            #   .PEM            PEM         NO              NO
        }
        "CertificateChain"      = [PSCustomObject] @{
            "DER"               = $oResultCertificatePackage.CertificateChain.DER       #   .CHAIN.DER      DER         YES             NO
            "KS"                = $oResultCertificatePackage.CertificateChain.KS        #   .KS             Java KS     YES             YES
            "P7B"               = $oResultEnterpriseCa.CertificateChain.P7B             #   .CHAIN.P7B      PKCS7       YES             NO  (Source from ADCS)
            "PEM"               = $oResultCertificatePackage.CertificateChain.PEM       #   .CHAIN.PEM      PEM         YES             NO
            "PFX"               = $oResultCertificatePackage.CertificateChain.PFX       #   .PFX            PKCS12      YES             YES
            "RSP"               = $oResultEnterpriseCa.CertificateChain.RSP             #   .CHAIN.RSP      RSP         YES             NO  (Source from ADCS)
        }
        "CaChain"               = $oResultCertificatePackage.CaChain                    #   .PEM            PEM         YES             NO  (Chain only)
    }
}


# Exported Functions
Export-ModuleMember -Function `
    Protect-PrivateKey, `
    Unprotect-PrivateKey, `
    ConvertTo-Der, `
    ConvertTo-JavaKeystore, `
    ConvertTo-Pem, `
    ConvertTo-Pfx, `
    ConvertTo-Pkcs1, `
    ConvertTo-Pkcs8, `
    Export-CaChain, `
    Get-EnterpriseCaList, `
    Find-CertificateIssuingEnterpriseCA, `
    New-OpenSslCertificateConfiguration, `
    New-CertificateSigningRequest, `
    New-SelfSignedCertificate, `
    New-EnterpriseCertificateAuthoritySignature, `
    Test-EnterpriseCertificateAuthoritySignature, `
    Revoke-EnterpriseCertificateAuthoritySignature, `
    Complete-CertificateSigningRequest, `
    New-CertificatePackage

